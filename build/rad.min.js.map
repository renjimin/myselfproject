{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///rad.min.js","webpack:///webpack/bootstrap b8d3facc6683b0dd4674","webpack:///./src/rad.js","webpack:///external {\"root\":\"_\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\",\"amd\":\"underscore\"}","webpack:///./src/plugins/index.js","webpack:///./src/plugins/transition_group/index.js","webpack:///./src/template/idom.js","webpack:///external {\"root\":\"Backbone\",\"commonjs2\":\"backbone\",\"commonjs\":\"backbone\",\"amd\":\"backbone\"}","webpack:///./src/core/dispatcher.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./src/utils/DOM_Utils.js","webpack:///./src/config/index.js","webpack:///./src/template/index.js","webpack:///./~/idom-template/bin/itemplate.js","webpack:///./src/template/binder.js","webpack:///./src/core/index.js","webpack:///./src/blanks/view.js","webpack:///./src/plugins/transition_group/utils.js","webpack:///./src/plugins/transition_group/contentHandler.js","webpack:///./src/plugins/transition_group/transition.js","webpack:///./src/utils/transition/animationEnd.js","webpack:///./src/utils/transition/transitionEnd.js","webpack:///./src/utils/transition/whichCssEvent.js","webpack:///./src/plugins/transition_group/options.js","webpack:///./src/plugins/transition_group/runner.js","webpack:///./src/plugins/layout_manager/index.js","webpack:///./src/blanks/module.js","webpack:///./src/plugins/navigator/index.js","webpack:///./src/utils/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_","RAD","core","utils","template","View","Module","extend","rootElementOpen","options","IncrementalDOM","elementOpenStart","tagName","key","each","omit","reservedAttrs","value","name","attr","el","elementOpenEnd","undefined","__firstRender","rootElementClose","attrs","elementClose","initRenderData","rootEl","children","toArray","keyMap","clone","getNodeData","keysRendered","keysToShow","position","firstRender","applyAnimation","initialAnimation","contentHandler","iTemplate","RunnerQuery","registerHelper","renderContent","console","warn","renderData","start","stop","runner","create","doTransition","run","setBooleanAttr","eventWrapper","event","args","method","params","Array","prototype","slice","incrementalDOM","events","trigger","apply","concat","result","patchWrapper","patch","node","renderFn","data","publish","Events","PATCH_START","PATCH_END","Backbone","attributeSetters","attributes","UtilsDOM","checked","disabled","readOnly","className","removeClass","__className","addClass","elementOpen","wrap","arguments","elementVoid","tag","patchInner","patchOuter","Dispatcher","subscribe","channel","callback","context","on","unsubscribe","off","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMapValid","text","Context","created","notifications","nodesCreated","deleted","nodesDeleted","hasOwnProperty","Object","has","map","property","initData","getData","toLowerCase","Element","getAttribute","symbols","default","placeholder","getNamespace","lastIndexOf","applyAttr","removeAttribute","attrNS","setAttributeNS","setAttribute","applyProp","applyStyle","style","cssText","elStyle","obj","prop","applyAttributeTyped","type","updateAttribute","mutator","getNamespaceForTag","parent","namespaceURI","createElement","doc","statics","namespace","createElementNS","i","length","createText","createTextNode","createKeyMap","child","firstElementChild","nextElementSibling","getKeyMap","getChild","registerChild","markCreated","push","markDeleted","notifyChanges","currentNode","currentParent","patchFactory","f","fn","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","ownerDocument","parentNode","enterNode","exitNode","nextSibling","matches","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","nextNode","firstChild","coreElementOpen","coreElementClose","coreText","currentElement","skip","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","j","_attr","elementPlaceholder","formatted","hasClass","cname","match","RegExp","cnames","classNames","split","forEach","replace","Config","Attributes","ID","ROLE","ViewOptions","REGISTER","UNREGISTER","ATTACH","DETACH","NODE_ATTACHED","NODE_REMOVED","str","templateFn","compile","content","helpers","binder","_options","prepare","Parser","Builder","wrapper","createWrapper","builder","parser","itemplate","string","library","scopedHelpers","rootKeys","reset","set","keys","parseComplete","unregisterHelper","defineProperty","get","BREAK_LINE","evaluate","interpolate","escape","order","open","close","accessory","MAP","&amp;","&lt;","&gt;","&quot;","emptyString","skipAttr","staticKey","staticArray","nonStaticAttributes","binderPre","helperPre","parameterName","parentParameterName","renderContentFnName","textSaveTags","voidRequireTags","debug","replacer","p1","methods","trim","_builder","Mode","_state","mode","Text","pos","pendingText","pendingWrite","lastTag","isScript","needData","output","done","parseChunk","chunk","substr","_parse","_flushWrite","_parseText","Tag","_parseTag","Attr","_parseAttr","CData","_parseCData","Doctype","_parseDoctype","Comment","_parseComment","_writePending","len","write","_write","_re_parseText_scriptClose","foundPos","state","lastIndex","exec","index","indexOf","substring","join","re_parseTag","raw","re_parseAttr_findName","_parseAttr_findName","re_parseAttr_findValue","re_parseAttr_findValue_last","_parseAttr_findValue","re_parseAttr_splitValue","re_parseAttr_selfClose","name_data","value_data","matchTrailingSlash","re_parseCData_findEnding","matchPartialCDataEnd","re_parseComment_findEnding","matchPartialCommentEnd","isRootNode","nestingLevelInfo","level","makeKey","possible","charAt","Math","floor","random","empty","decodeAccessory","force","code","openStub","closeStub","regex","isStatic","piece","JSON","stringify","formatText","dec","String","fromCharCode","prepareKey","command","useKeyCommand","decode","stub","Command","getKey","prepareAttr","skipCommand","arrayStaticKey","isSkipped","staticArraysHolder","startSkipContent","removable","comma","quote","unwrapStaticArrays","holder","arrayName","decodeAttrs","camelCase","input","group1","toUpperCase","writeCommand","ref","refName","strKey","strAttrs","saveRef","stack","writeText","helperOpen","helperName","helperClose","isHelperTag","localComponentNames","binderOpen","fnName","binderClose","isTagBinded","writeAndCloseOpenState","isClosed","isShouldClose","isRoot","functionWrapper","helpersKeys","localNames","endSkipContent","pop","wrapFn","body","returnValue","eol","prepareError","_template","resultFn","variables","glue","_library","Function","_helpers","_fnName","flag","component","props","BaseView","silent","render","registrationId","registeredComponent","newComponent","isFunction","Core","defaults","InternalEvents","register","unregister","viewAttributes","data-role","setOptions","getAll","Error","isRendering","makeId","uniqueId","compileTemplate","hasKey","__incrementalDOMData","defaultAttributes","viewId","refs","Props","propsModel","Model","_bindChannels","bindRender","getID","attachMsg","detachMsg","onReceiveMsg","onAttach","onDetach","destroy","setElement","$el","$","getTemplateData","collection","toJSON","model","target","listenTo","_render","_renderOuter","self","onBeforeRender","_skip","_viewElOpen","_renderTemplate","_viewElClose","onRender","_setElAttributes","_removeElement","remove","onDestroy","undelegateEvents","protoProps","staticProps","IDOM_DATA","setRenderData","RENDER_DATA","getRenderData","startIndex","createPlaceholder","isPlaceholder","iDOM","alignContent","renderStart","beforeCreate","isChild","childLevel","isNewChild","afterCreate","splice","elementOpenKey","renderStop","activeKeys","transitionOptions","initTransitionOptions","enterTimeout","leaveTimeout","status","RenderStatus","LEAVE","ENTER","transition","enter","DONE","leave","clearTransitionTimeout","__transitionId","clearTimeout","setTransitionTimeout","cb","timeout","setTimeout","hasActiveTransition","stopActiveTransition","onTransitionEnd","e","transitionEnd","TransitionEnd","animationEnd","AnimationEnd","triggers","animationEnter","animationLeave","enterClass","leaveClass","activeClass","sep","unbindAll","utilsDOM","bind","transitionLeave","transitionEnter","whichCssEvent","ANIMATION_DATA","constructor","_initData","eventName","animation","MozAnimation","WebkitAnimation","callbacks","_getData","HTMLElement","TRANSITION_DATA","MozTransition","WebkitTransition","addEventListener","unbind","removeEventListener","eventsMap","testEl","document","DEFAULT_LEAVE_CLASS","DEFAULT_ENTER_CLASS","DEFAULT_ACTIVE_CLASS","DEFAULT_TIMEOUT","parseInt","animationName","isNaN","Runner","execute","query","runners","delay","toString","groupName","Attrs","LayoutManager","activePatches","initialize","onPatchStart","onPatchEnd","onNodeRemove","ids","getChildIDs","activeViews","filter","hasAttribute","unshift","publishEvent","isOnPage","contains","views","patchData","refreshLayout","els","querySelectorAll","viewsBefore","viewsAfter","detachedViews","difference","attachedViews","subscribers","cid","pick","moduleOptions","renderView","Navigator","navigateView","navigateBack","container","getEl","patchContainer","getContent","direction","selector","isString","querySelector","view","DOM","ITemplate"],"mappings":"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","file":"rad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"backbone\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RAD\"] = factory(require(\"underscore\"), require(\"backbone\"));\n\telse\n\t\troot[\"RAD\"] = factory(root[\"_\"], root[\"Backbone\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"backbone\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RAD\"] = factory(require(\"underscore\"), require(\"backbone\"));\n\telse\n\t\troot[\"RAD\"] = factory(root[\"_\"], root[\"Backbone\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar _ = __webpack_require__(1);\n\t\n\t// Init plugins\n\t__webpack_require__(2);\n\t\n\t/**\n\t *\n\t * RAD namespace.\n\t * @namespace\n\t */\n\t\n\tvar RAD = {};\n\t\n\tRAD.core = __webpack_require__(13);\n\tRAD.utils = __webpack_require__(26);\n\tRAD.template = __webpack_require__(10);\n\tRAD.View = __webpack_require__(14);\n\tRAD.Module = __webpack_require__(24);\n\t\n\t// Extend with Dispatcher API: publish, subscribe, unsubscribe\n\t_.extend(RAD, __webpack_require__(6));\n\t\n\tmodule.exports = RAD;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(3);\n\t__webpack_require__(23);\n\t__webpack_require__(25);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(1);\n\tvar IncrementalDOM = __webpack_require__(4);\n\tvar template = __webpack_require__(10);\n\tvar utils = __webpack_require__(15);\n\tvar contentHandler = __webpack_require__(16);\n\tvar iTemplate = __webpack_require__(11);\n\tvar RunnerQuery = __webpack_require__(22);\n\t\n\tvar reservedAttrs = [\n\t    'name', // deprecated\n\t    'tagName',\n\t    'key',\n\t\n\t    'initialAnimation',\n\t    'animationName',\n\t    'animationEnter',\n\t    'animationLeave',\n\t    'enterTimeout',\n\t    'leaveTimeout',\n\t\n\t    'enterClass',\n\t    'leaveClass',\n\t    'activeClass',\n\t    'delay',\n\t    'groupName'\n\t];\n\t\n\tfunction rootElementOpen(options) {\n\t    IncrementalDOM.elementOpenStart(options.tagName || 'div', options.key);\n\t\n\t    _.each(_.omit(options, reservedAttrs), function (value, name) {\n\t        IncrementalDOM.attr(name, value);\n\t    });\n\t\n\t    var el = IncrementalDOM.elementOpenEnd();\n\t\n\t    if (el.__firstRender === undefined) {\n\t        el.__firstRender = true;\n\t    }\n\t\n\t    return el;\n\t}\n\t\n\tfunction rootElementClose(attrs) {\n\t    var el = IncrementalDOM.elementClose(attrs.tagName);\n\t    el.__firstRender = false;\n\t    return el;\n\t}\n\t\n\tfunction initRenderData(rootEl, attrs) {\n\t    return {\n\t        rootEl: rootEl,\n\t        attrs: attrs,\n\t        children: utils.toArray(rootEl.children),\n\t        keyMap: _.clone(utils.getNodeData(rootEl).keyMap) || {},\n\t        keysRendered: {},\n\t        keysToShow: {},\n\t        position: 0,\n\t        firstRender: rootEl.__firstRender,\n\t        applyAnimation: !rootEl.__firstRender || attrs.initialAnimation !== 'none'\n\t    };\n\t}\n\t\n\tiTemplate.registerHelper('i-transition', function(options, renderContent) {\n\t    if (options.name) {\n\t        console.warn('Warning: `name` is deprecated attribute for transitionGroup, use `animationName` instead');\n\t    }\n\t\n\t    var rootEl = rootElementOpen(options);\n\t    var renderData = initRenderData(rootEl, options);\n\t\n\t    contentHandler.start(renderData);\n\t    renderContent();\n\t    contentHandler.stop(renderData);\n\t    rootElementClose(options);\n\t\n\t    var runner = RunnerQuery.create(options);\n\t    contentHandler.doTransition(renderData, runner);\n\t    RunnerQuery.run(runner.name);\n\t});\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _ = __webpack_require__(1);\n\tvar Backbone = __webpack_require__(5);\n\tvar publish = __webpack_require__(6).publish;\n\tvar incrementalDOM = __webpack_require__(7);\n\tvar attributeSetters = incrementalDOM.attributes;\n\tvar UtilsDOM = __webpack_require__(8);\n\tvar Events = __webpack_require__(9).Events;\n\t\n\t// Sett HTMlInput [checked], [disabled] and [readonly] attributes as properties\n\tfunction setBooleanAttr(el, attr, value) {\n\t    el[attr] = !!value;\n\t}\n\t\n\tattributeSetters.checked  = setBooleanAttr;\n\tattributeSetters.disabled = setBooleanAttr;\n\tattributeSetters.readOnly = setBooleanAttr;\n\t\n\t// Class names muttator handle classes added only via template.\n\t// Any classes added via DOM manipulation will stay untouched and must be handled by user\n\tattributeSetters.className = attributeSetters['class'] = function(el, attr, value) {\n\t    value = value || '';\n\t\n\t    UtilsDOM.removeClass(el, el.__className);\n\t    UtilsDOM.addClass(el, value);\n\t    el.__className = value;\n\t};\n\t\n\tincrementalDOM.events = _.clone(Backbone.Events);\n\t\n\tfunction eventWrapper(event, args) {\n\t    var method = args[0];\n\t    var params = Array.prototype.slice.call(args, 1);\n\t    incrementalDOM.events.trigger.apply(incrementalDOM.events, [event + ':before'].concat(params));\n\t    var result = method.apply(null, params);\n\t    incrementalDOM.events.trigger.apply(incrementalDOM.events, [event + ':after'].concat(params));\n\t    return result;\n\t}\n\t\n\tincrementalDOM.elementOpen = _.wrap(incrementalDOM.elementOpen, function() {\n\t    return eventWrapper('elementOpen', arguments);\n\t});\n\tincrementalDOM.elementClose = _.wrap(incrementalDOM.elementClose, function() {\n\t    return eventWrapper('elementClose', arguments);\n\t});\n\tincrementalDOM.elementOpenStart = _.wrap(incrementalDOM.elementOpenStart, function() {\n\t    return eventWrapper('elementOpenStart', arguments);\n\t});\n\tincrementalDOM.elementOpenEnd = _.wrap(incrementalDOM.elementOpenEnd, function() {\n\t    return eventWrapper('elementOpenEnd', arguments);\n\t});\n\tincrementalDOM.elementVoid = function(tag) {\n\t    incrementalDOM.elementOpen.apply(null, arguments);\n\t    return incrementalDOM.elementClose(tag);\n\t};\n\t\n\t\n\tfunction patchWrapper(patch, node, renderFn, data) {\n\t    publish(Events.PATCH_START, node);\n\t    patch.call(null, node, renderFn, data);\n\t    publish(Events.PATCH_END, node);\n\t}\n\t\n\tincrementalDOM.patch = incrementalDOM.patchInner = _.wrap(incrementalDOM.patchInner, patchWrapper);\n\tincrementalDOM.patchOuter = _.wrap(incrementalDOM.patchOuter, patchWrapper);\n\t\n\tmodule.exports = incrementalDOM;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _ = __webpack_require__(1);\n\tvar Backbone = __webpack_require__(5);\n\tvar Dispatcher = _.clone(Backbone.Events);\n\t\n\t\n\tmodule.exports = {\n\t    publish: function() {\n\t        Dispatcher.trigger.apply(Dispatcher, arguments);\n\t    },\n\t    subscribe: function(channel, callback, context) {\n\t        Dispatcher.on(channel, callback, context);\n\t    },\n\t    unsubscribe: function(channel, callback, context) {\n\t        Dispatcher.off(channel, callback, context);\n\t    }\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction hasClass(el, cname) {\n\t    return el.className ? el.className.match(new RegExp('(\\\\s|^)'+cname+'(\\\\s|$)')) : false;\n\t}\n\t\n\tfunction addClass(el, cnames) {\n\t    var classNames = cnames ? cnames.split(' ') : [];\n\t\n\t    classNames.forEach(function(cname){\n\t        if (!hasClass(el, cname)) {\n\t            el.className = el.className ? el.className + \" \" + cname : cname;\n\t        }\n\t    }, this);\n\t}\n\t\n\tfunction removeClass(el, cnames) {\n\t    var classNames = cnames ? cnames.split(' ') : [];\n\t\n\t    classNames.forEach(function(cname){\n\t        if (hasClass(el, cname)) {\n\t            el.className = el.className.replace(new RegExp('(\\\\s|^)'+cname+'(?=\\\\s|$)'),'');\n\t        }\n\t    }, this);\n\t}\n\t\n\tmodule.exports.hasClass = hasClass;\n\tmodule.exports.addClass = addClass;\n\tmodule.exports.removeClass = removeClass;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar Config = {\n\t    // Specific RAD.js attributes to connect HTMLElement with its View\n\t    Attributes: {\n\t        ID: 'view-id',\n\t        ROLE: 'data-role'\n\t    },\n\t\n\t    // List of BaseView parameters which can be applied by passing as an options.\n\t    ViewOptions: ['key', 'propsModel', 'model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'],\n\t\n\t    // Internal Events used to communicate with modules\n\t    Events: {\n\t        REGISTER: 'register',\n\t        UNREGISTER: 'unregister',\n\t\n\t        ATTACH: 'attach',\n\t        DETACH: 'detach',\n\t\n\t        NODE_ATTACHED: 'nodeAdded',\n\t        NODE_REMOVED: 'nodeRemoved',\n\t\n\t        PATCH_START: 'patchStart',\n\t        PATCH_END:'patchEnd'\n\t    }\n\t};\n\t\n\tmodule.exports = Config;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar IncrementalDOM = __webpack_require__(7);\n\tvar _ = __webpack_require__(1);\n\tvar iTemplate = __webpack_require__(11);\n\tvar binder = __webpack_require__(12);\n\t\n\t/**\n\t *\n\t * Compile ejs string into IncrementalDOM annotation. iTemplate used for compiling.\n\t * @param {string} str - input EJS template string\n\t *\n\t * */\n\t\n\tfunction template(str) {\n\t    var templateFn = iTemplate.compile(str, null);\n\t\n\t    return function (data, content) {\n\t        return templateFn.call(this, data, IncrementalDOM, iTemplate.helpers, content, binder);\n\t    };\n\t}\n\t\n\tmodule.exports = template;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"itemplate\"] = factory();\n\t\telse\n\t\t\troot[\"itemplate\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar _options = __webpack_require__(1);\n\t\tvar prepare = __webpack_require__(2);\n\t\tvar Parser = __webpack_require__(3);\n\t\tvar Builder = __webpack_require__(5);\n\t\n\t\tvar wrapper = __webpack_require__(6).createWrapper();\n\t\tvar builder = new Builder(wrapper);\n\t\tvar parser = new Parser(builder);\n\t\n\t\tvar helpers = {};\n\t\n\t\tvar itemplate = {\n\t\t    compile: function (string, library, scopedHelpers, rootKeys) {\n\t\t        builder.reset();\n\t\t        builder.set(\n\t\t            Object.keys(helpers),\n\t\t            scopedHelpers ? Object.keys(scopedHelpers) : [],\n\t\t            rootKeys\n\t\t        );\n\t\t        wrapper.set(library, helpers, null, string);\n\t\t        return parser.parseComplete(prepare(string));\n\t\t    },\n\t\t    options: function (options) {\n\t\t        // mix options\n\t\t        for (var key in options) {\n\t\t            if (options.hasOwnProperty(key))\n\t\t                _options[key] = options[key];\n\t\t        }\n\t\t    },\n\t\t    registerHelper: function (name, fn) {\n\t\t        helpers[name] = fn;\n\t\t    },\n\t\t    unregisterHelper: function (name) {\n\t\t        delete helpers[name];\n\t\t    }\n\t\t};\n\t\n\t\tObject.defineProperty(itemplate, 'helpers', {\n\t\t    get: function () {\n\t\t        return helpers;\n\t\t    },\n\t\t    set: function () {\n\t\t    }\n\t\t});\n\t\n\t\tmodule.exports = itemplate;\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tvar _options = {\n\t\t    BREAK_LINE: /(\\r\\n|\\n|\\r)\\s{0,}/gm,\n\t\t    // prepare options\n\t\t    template: {\n\t\t        evaluate: /<%([\\s\\S]+?)%>/g,\n\t\t        interpolate: /<%=([\\s\\S]+?)%>/g,\n\t\t        escape: /<%-([\\s\\S]+?)%>/g\n\t\t    },\n\t\t    order: ['interpolate', 'escape', 'evaluate'],\n\t\t    evaluate: {\n\t\t        name: 'script',\n\t\t        open: '<script>',\n\t\t        close: '</script>'\n\t\t    },\n\t\t    accessory: {\n\t\t        open: '{%',\n\t\t        close: '%}'\n\t\t    },\n\t\t    escape: /(&amp;|&lt;|&gt;|&quot;)/g,\n\t\t    MAP: {\n\t\t        '&amp;': '&',\n\t\t        '&lt;': '<',\n\t\t        '&gt;': '>',\n\t\t        '&quot;': '\"'\n\t\t    },\n\t\t    // build options\n\t\t    emptyString: true,\n\t\t    skipAttr: 'skip',\n\t\t    staticKey: 'key',\n\t\t    staticArray: 'static-array',\n\t\t    nonStaticAttributes: ['id', 'name', 'ref'],\n\t\t    binderPre: '::',\n\t\t    helperPre: 'i-',\n\t\t    parameterName: 'data',\n\t\t    parentParameterName: 'parent',\n\t\t    renderContentFnName: 'content',\n\t\t    // tags parse rules\n\t\t    textSaveTags: ['pre', 'code'],\n\t\t    voidRequireTags: ['input', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'keygen', 'link', 'meta',\n\t\t        'param', 'source', 'track', 'wbr'],\n\t\t    debug: false\n\t\t};\n\t\n\t\tmodule.exports = _options;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar _options = __webpack_require__(1);\n\t\n\t\tfunction replacer(match, p1) {\n\t\t    return _options.accessory.open + p1 + _options.accessory.close;\n\t\t}\n\t\n\t\tvar methods = {\n\t\t    evaluate: function (string) {\n\t\t        return string.replace(_options.template.evaluate, function (match, p1) {\n\t\t            return _options.evaluate.open + p1.replace(_options.BREAK_LINE, ' ').trim() + _options.evaluate.close;\n\t\t        });\n\t\t    },\n\t\t    interpolate: function (string) {\n\t\t        return string.replace(_options.template.interpolate, replacer);\n\t\t    },\n\t\t    escape: function (string) {\n\t\t        return string.replace(_options.template.escape, replacer);\n\t\t    }\n\t\t};\n\t\n\t\tfunction prepare(string) {\n\t\t    var result = string;\n\t\t    for (var i = 0; i < _options.order.length; i++) {\n\t\t        result = methods[_options.order[i]](result);\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\n\t\tmodule.exports = prepare;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar Mode = __webpack_require__(4);\n\t\n\t\tfunction Parser(builder) {\n\t\t    this._builder = builder;\n\t\t    this.reset();\n\t\t}\n\t\n\t\t//**Public**//\n\t\tParser.prototype.reset = function () {\n\t\t    this._state = {\n\t\t        mode: Mode.Text,\n\t\t        pos: 0,\n\t\t        data: null,\n\t\t        pendingText: null,\n\t\t        pendingWrite: null,\n\t\t        lastTag: null,\n\t\t        isScript: false,\n\t\t        needData: false,\n\t\t        output: [],\n\t\t        done: false\n\t\t    };\n\t\t    this._builder.reset();\n\t\t};\n\t\n\t\tParser.prototype.parseChunk = function (chunk) {\n\t\t    this._state.needData = false;\n\t\t    this._state.data = (this._state.data !== null) ? this._state.data.substr(this.pos) + chunk : chunk;\n\t\t    while (this._state.pos < this._state.data.length && !this._state.needData) {\n\t\t        this._parse(this._state);\n\t\t    }\n\t\t};\n\t\n\t\tParser.prototype.parseComplete = function (data) {\n\t\t    this.reset();\n\t\t    this.parseChunk(data);\n\t\t    return this.done();\n\t\t};\n\t\n\t\tParser.prototype.done = function () {\n\t\t    this._state.done = true;\n\t\t    this._parse(this._state);\n\t\t    this._flushWrite();\n\t\t    return this._builder.done();\n\t\t};\n\t\n\t\t//**Private**//\n\t\tParser.prototype._parse = function () {\n\t\t    switch (this._state.mode) {\n\t\t        case Mode.Text:\n\t\t            return this._parseText(this._state);\n\t\t        case Mode.Tag:\n\t\t            return this._parseTag(this._state);\n\t\t        case Mode.Attr:\n\t\t            return this._parseAttr(this._state);\n\t\t        case Mode.CData:\n\t\t            return this._parseCData(this._state);\n\t\t        case Mode.Doctype:\n\t\t            return this._parseDoctype(this._state);\n\t\t        case Mode.Comment:\n\t\t            return this._parseComment(this._state);\n\t\t    }\n\t\t};\n\t\n\t\tParser.prototype._writePending = function (node) {\n\t\t    if (!this._state.pendingWrite) {\n\t\t        this._state.pendingWrite = [];\n\t\t    }\n\t\t    this._state.pendingWrite.push(node);\n\t\t};\n\t\n\t\tParser.prototype._flushWrite = function () {\n\t\t    if (this._state.pendingWrite) {\n\t\t        for (var i = 0, len = this._state.pendingWrite.length; i < len; i++) {\n\t\t            var node = this._state.pendingWrite[i];\n\t\t            this._builder.write(node);\n\t\t        }\n\t\t        this._state.pendingWrite = null;\n\t\t    }\n\t\t};\n\t\n\t\tParser.prototype._write = function (node) {\n\t\t    this._flushWrite();\n\t\t    this._builder.write(node);\n\t\t};\n\t\n\t\tParser._re_parseText_scriptClose = /<\\s*\\/\\s*script/ig;\n\t\tParser.prototype._parseText = function () {\n\t\t    var state = this._state;\n\t\t    var foundPos;\n\t\t    if (state.isScript) {\n\t\t        Parser._re_parseText_scriptClose.lastIndex = state.pos;\n\t\t        foundPos = Parser._re_parseText_scriptClose.exec(state.data);\n\t\t        foundPos = (foundPos) ? foundPos.index : -1;\n\t\t    } else {\n\t\t        foundPos = state.data.indexOf('<', state.pos);\n\t\t    }\n\t\t    var text = (foundPos === -1) ? state.data.substring(state.pos, state.data.length) : state.data.substring(state.pos, foundPos);\n\t\t    if (foundPos < 0 && state.done) {\n\t\t        foundPos = state.data.length;\n\t\t    }\n\t\t    if (foundPos < 0) {\n\t\t        if (state.isScript) {\n\t\t            state.needData = true;\n\t\t            return;\n\t\t        }\n\t\t        if (!state.pendingText) {\n\t\t            state.pendingText = [];\n\t\t        }\n\t\t        state.pendingText.push(state.data.substring(state.pos, state.data.length));\n\t\t        state.pos = state.data.length;\n\t\t    } else {\n\t\t        if (state.pendingText) {\n\t\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t\t            text = state.pendingText.join('');\n\t\t            state.pendingText = null;\n\t\t        } else {\n\t\t            text = state.data.substring(state.pos, foundPos);\n\t\t        }\n\t\t        if (text !== '') {\n\t\t            this._write({type: Mode.Text, data: text});\n\t\t        }\n\t\t        state.pos = foundPos + 1;\n\t\t        state.mode = Mode.Tag;\n\t\t    }\n\t\t};\n\t\n\t\tParser.re_parseTag = /\\s*(\\/?)\\s*([^\\s>\\/]+)(\\s*)\\??(>?)/g;\n\t\tParser.prototype._parseTag = function () {\n\t\t    var state = this._state;\n\t\t    Parser.re_parseTag.lastIndex = state.pos;\n\t\t    var match = Parser.re_parseTag.exec(state.data);\n\t\n\t\t    if (match) {\n\t\t        if (!match[1] && match[2].substr(0, 3) === '!--') {\n\t\t            state.mode = Mode.Comment;\n\t\t            state.pos += 3;\n\t\t            return;\n\t\t        }\n\t\t        if (!match[1] && match[2].substr(0, 8) === '![CDATA[') {\n\t\t            state.mode = Mode.CData;\n\t\t            state.pos += 8;\n\t\t            return;\n\t\t        }\n\t\t        if (!match[1] && match[2].substr(0, 8) === '!DOCTYPE') {\n\t\t            state.mode = Mode.Doctype;\n\t\t            state.pos += 8;\n\t\t            return;\n\t\t        }\n\t\t        if (!state.done && (state.pos + match[0].length) === state.data.length) {\n\t\t            //We're at the and of the data, might be incomplete\n\t\t            state.needData = true;\n\t\t            return;\n\t\t        }\n\t\t        var raw;\n\t\t        if (match[4] === '>') {\n\t\t            state.mode = Mode.Text;\n\t\t            raw = match[0].substr(0, match[0].length - 1);\n\t\t        } else {\n\t\t            state.mode = Mode.Attr;\n\t\t            raw = match[0];\n\t\t        }\n\t\t        state.pos += match[0].length;\n\t\t        var tag = {type: Mode.Tag, name: match[1] + match[2], raw: raw, position: Parser.re_parseTag.lastIndex };\n\t\t        if (state.mode === Mode.Attr) {\n\t\t            state.lastTag = tag;\n\t\t        }\n\t\t        if (tag.name.toLowerCase() === 'script') {\n\t\t            state.isScript = true;\n\t\t        } else if (tag.name.toLowerCase() === '/script') {\n\t\t            state.isScript = false;\n\t\t        }\n\t\t        if (state.mode === Mode.Attr) {\n\t\t            this._writePending(tag);\n\t\t        } else {\n\t\t            this._write(tag);\n\t\t        }\n\t\t    } else {\n\t\t        state.needData = true;\n\t\t    }\n\t\t};\n\t\n\t\tParser.re_parseAttr_findName = /\\s*([^=<>\\s'\"\\/]+)\\s*/g;\n\t\tParser.prototype._parseAttr_findName = function () {\n\t\t    // todo: parse {{ checked ? 'checked' : '' }} in input\n\t\t    Parser.re_parseAttr_findName.lastIndex = this._state.pos;\n\t\t    var match = Parser.re_parseAttr_findName.exec(this._state.data);\n\t\t    if (!match) {\n\t\t        return null;\n\t\t    }\n\t\t    if (this._state.pos + match[0].length !== Parser.re_parseAttr_findName.lastIndex) {\n\t\t        return null;\n\t\t    }\n\t\t    return {\n\t\t        match: match[0],\n\t\t        name: match[1]\n\t\t    };\n\t\t};\n\t\tParser.re_parseAttr_findValue = /\\s*=\\s*(?:'([^']*)'|\"([^\"]*)\"|([^'\"\\s\\/>]+))\\s*/g;\n\t\tParser.re_parseAttr_findValue_last = /\\s*=\\s*['\"]?(.*)$/g;\n\t\tParser.prototype._parseAttr_findValue = function () {\n\t\t    var state = this._state;\n\t\t    Parser.re_parseAttr_findValue.lastIndex = state.pos;\n\t\t    var match = Parser.re_parseAttr_findValue.exec(state.data);\n\t\t    if (!match) {\n\t\t        if (!state.done) {\n\t\t            return null;\n\t\t        }\n\t\t        Parser.re_parseAttr_findValue_last.lastIndex = state.pos;\n\t\t        match = Parser.re_parseAttr_findValue_last.exec(state.data);\n\t\t        if (!match) {\n\t\t            return null;\n\t\t        }\n\t\t        return {\n\t\t            match: match[0],\n\t\t            value: (match[1] !== '') ? match[1] : null\n\t\t        };\n\t\t    }\n\t\t    if (state.pos + match[0].length !== Parser.re_parseAttr_findValue.lastIndex) {\n\t\t        return null;\n\t\t    }\n\t\t    return {\n\t\t        match: match[0],\n\t\t        value: match[1] || match[2] || match[3]\n\t\t    };\n\t\t};\n\t\tParser.re_parseAttr_splitValue = /\\s*=\\s*['\"]?/g;\n\t\tParser.re_parseAttr_selfClose = /(\\s*\\/\\s*)(>?)/g;\n\t\tParser.prototype._parseAttr = function () {\n\t\t    var state = this._state;\n\t\t    var name_data = this._parseAttr_findName(state);\n\t\t    if (!name_data || name_data.name === '?') {\n\t\t        Parser.re_parseAttr_selfClose.lastIndex = state.pos;\n\t\t        var matchTrailingSlash = Parser.re_parseAttr_selfClose.exec(state.data);\n\t\t        if (matchTrailingSlash && matchTrailingSlash.index === state.pos) {\n\t\t            if (!state.done && !matchTrailingSlash[2] && state.pos + matchTrailingSlash[0].length === state.data.length) {\n\t\t                state.needData = true;\n\t\t                return;\n\t\t            }\n\t\t            state.lastTag.raw += matchTrailingSlash[1];\n\t\t            this._write({type: Mode.Tag, name: '/' + state.lastTag.name, raw: null});\n\t\t            state.pos += matchTrailingSlash[1].length;\n\t\t        }\n\t\t        var foundPos = state.data.indexOf('>', state.pos);\n\t\t        if (foundPos < 0) {\n\t\t            if (state.done) {\n\t\t                state.lastTag.raw += state.data.substr(state.pos);\n\t\t                state.pos = state.data.length;\n\t\t                return;\n\t\t            }\n\t\t            state.needData = true;\n\t\t        } else {\n\t\t            // state.lastTag = null;\n\t\t            state.pos = foundPos + 1;\n\t\t            state.mode = Mode.Text;\n\t\t        }\n\t\t        return;\n\t\t    }\n\t\t    if (!state.done && state.pos + name_data.match.length === state.data.length) {\n\t\t        state.needData = true;\n\t\t        return null;\n\t\t    }\n\t\t    state.pos += name_data.match.length;\n\t\t    var value_data = this._parseAttr_findValue(state);\n\t\t    if (value_data) {\n\t\t        if (!state.done && state.pos + value_data.match.length === state.data.length) {\n\t\t            state.needData = true;\n\t\t            state.pos -= name_data.match.length;\n\t\t            return;\n\t\t        }\n\t\t        state.pos += value_data.match.length;\n\t\t    } else {\n\t\t        if (state.data.indexOf(' ', state.pos - 1)) {\n\t\t            value_data = {\n\t\t                match: '',\n\t\t                value: null\n\t\t            };\n\t\n\t\t        } else {\n\t\t            Parser.re_parseAttr_splitValue.lastIndex = state.pos;\n\t\t            if (Parser.re_parseAttr_splitValue.exec(state.data)) {\n\t\t                state.needData = true;\n\t\t                state.pos -= name_data.match.length;\n\t\t                return;\n\t\t            }\n\t\t            value_data = {\n\t\t                match: '',\n\t\t                value: null\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    state.lastTag.raw += name_data.match + value_data.match;\n\t\n\t\t    this._writePending({type: Mode.Attr, name: name_data.name, data: value_data.value});\n\t\t};\n\t\n\t\tParser.re_parseCData_findEnding = /\\]{1,2}$/;\n\t\tParser.prototype._parseCData = function () {\n\t\t    var state = this._state;\n\t\t    var foundPos = state.data.indexOf(']]>', state.pos);\n\t\t    if (foundPos < 0 && state.done) {\n\t\t        foundPos = state.data.length;\n\t\t    }\n\t\t    if (foundPos < 0) {\n\t\t        Parser.re_parseCData_findEnding.lastIndex = state.pos;\n\t\t        var matchPartialCDataEnd = Parser.re_parseCData_findEnding.exec(state.data);\n\t\t        if (matchPartialCDataEnd) {\n\t\t            state.needData = true;\n\t\t            return;\n\t\t        }\n\t\t        if (!state.pendingText) {\n\t\t            state.pendingText = [];\n\t\t        }\n\t\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t\t        state.pos = state.data.length;\n\t\t        state.needData = true;\n\t\t    } else {\n\t\t        var text;\n\t\t        if (state.pendingText) {\n\t\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t\t            text = state.pendingText.join('');\n\t\t            state.pendingText = null;\n\t\t        } else {\n\t\t            text = state.data.substring(state.pos, foundPos);\n\t\t        }\n\t\t        this._write({type: Mode.CData, data: text});\n\t\t        state.mode = Mode.Text;\n\t\t        state.pos = foundPos + 3;\n\t\t    }\n\t\t};\n\t\n\t\tParser.prototype._parseDoctype = function () {\n\t\t    var state = this._state;\n\t\t    var foundPos = state.data.indexOf('>', state.pos);\n\t\t    if (foundPos < 0 && state.done) {\n\t\t        foundPos = state.data.length;\n\t\t    }\n\t\t    if (foundPos < 0) {\n\t\t        Parser.re_parseCData_findEnding.lastIndex = state.pos;\n\t\t        if (!state.pendingText) {\n\t\t            state.pendingText = [];\n\t\t        }\n\t\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t\t        state.pos = state.data.length;\n\t\t        state.needData = true;\n\t\t    } else {\n\t\t        var text;\n\t\t        if (state.pendingText) {\n\t\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t\t            text = state.pendingText.join('');\n\t\t            state.pendingText = null;\n\t\t        } else {\n\t\t            text = state.data.substring(state.pos, foundPos);\n\t\t        }\n\t\t        this._write({type: Mode.Doctype, data: text});\n\t\t        state.mode = Mode.Text;\n\t\t        state.pos = foundPos + 1;\n\t\t    }\n\t\t};\n\t\n\t\tParser.re_parseComment_findEnding = /\\-{1,2}$/;\n\t\tParser.prototype._parseComment = function () {\n\t\t    var state = this._state;\n\t\t    var foundPos = state.data.indexOf('-->', state.pos);\n\t\t    if (foundPos < 0 && state.done) {\n\t\t        foundPos = state.data.length;\n\t\t    }\n\t\t    if (foundPos < 0) {\n\t\t        Parser.re_parseComment_findEnding.lastIndex = state.pos;\n\t\t        var matchPartialCommentEnd = Parser.re_parseComment_findEnding.exec(state.data);\n\t\t        if (matchPartialCommentEnd) {\n\t\t            state.needData = true;\n\t\t            return;\n\t\t        }\n\t\t        if (!state.pendingText) {\n\t\t            state.pendingText = [];\n\t\t        }\n\t\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t\t        state.pos = state.data.length;\n\t\t        state.needData = true;\n\t\t    } else {\n\t\t        var text;\n\t\t        if (state.pendingText) {\n\t\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t\t            text = state.pendingText.join('');\n\t\t            state.pendingText = null;\n\t\t        } else {\n\t\t            text = state.data.substring(state.pos, foundPos);\n\t\t        }\n\t\n\t\t        this._write({type: Mode.Comment, data: text});\n\t\t        state.mode = Mode.Text;\n\t\t        state.pos = foundPos + 3;\n\t\t    }\n\t\t};\n\t\n\t\tmodule.exports = Parser;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tvar Mode = {\n\t\t    Text: 'text',\n\t\t    Tag: 'tag',\n\t\t    Attr: 'attr',\n\t\t    CData: 'cdata',\n\t\t    Doctype: 'doctype',\n\t\t    Comment: 'comment'\n\t\t};\n\t\n\t\tmodule.exports = Mode;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/* private */\n\t\tvar _options = __webpack_require__(1);\n\t\tvar Mode = __webpack_require__(4);\n\t\tvar Command = __webpack_require__(6).Command;\n\t\n\t\tvar state; // current builder state\n\t\tvar stack; // result builder\n\t\tvar staticArraysHolder = {}; // holder for static arrays\n\t\tvar wrapper; // external wrapper functionality\n\t\tvar helpers; // keys for helpers\n\t\tvar localComponentNames = []; // keys for local helpers\n\t\n\t\tvar empty = '', quote = '\"', comma = ', \"', removable = '-%%&&##__II-'; // auxiliary\n\t\n\t\tvar nestingLevelInfo = {level: 0, skip: []};\n\t\n\t\tfunction isRootNode() {\n\t\t    return nestingLevelInfo.level === 0;\n\t\t}\n\t\n\t\tfunction makeKey() {\n\t\t    var text = new Array(12), possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefgijklmnopqrstuvwxyz';\n\t\t    for (var i = 0; i < 12; i++)\n\t\t        text.push(possible.charAt(Math.floor(Math.random() * possible.length)));\n\t\n\t\t    return text.join(empty);\n\t\t}\n\t\n\t\tfunction decodeAccessory(string, force) {\n\t\t    var regex = new RegExp(_options.accessory.open + '|' + _options.accessory.close, 'g');\n\t\t    var code;\n\t\t    var isStatic = true, openStub, closeStub;\n\t\n\t\t    if (string !== undefined)\n\t\t        code = string.split(regex).map(function (piece, i) {\n\t\t            openStub = '';\n\t\t            closeStub = '';\n\t\n\t\t            if (i % 2) {\n\t\t                isStatic = false;\n\t\t                piece = piece.trim();\n\t\t                if (_options.emptyString && !force) { // undefined as empty string\n\t\t                    if (piece.indexOf(' ') !== -1) {\n\t\t                        openStub = '(';\n\t\t                        closeStub = ')';\n\t\t                    }\n\t\t                    return ' + (' + openStub + piece + closeStub + ' === undefined ? \"\" : '\n\t\t                        + openStub + piece + closeStub + ') + ';\n\t\t                } else\n\t\t                    return ' + ' + piece + ' + ';\n\t\t            } else {\n\t\t                return JSON.stringify(piece);\n\t\t            }\n\t\t        }).join('');\n\t\t    else\n\t\t        code = '\"\"';\n\t\n\t\t    // micro-optimizations (remove appending empty strings)\n\t\t    code = code.replace(/^\"\" \\+ | \\+ \"\"$/g, '').replace(/ \\+ \"\" \\+ /g, ' + ');\n\t\n\t\t    return {value: code, isStatic: isStatic};\n\t\t}\n\t\n\t\tfunction formatText(text) {\n\t\t    return text.trim()\n\t\t        .replace(/&#(\\d+);/g, function (match, dec) {\n\t\t            return String.fromCharCode(dec);\n\t\t        })\n\t\t        .replace(_options.escape, function (m) {\n\t\t            return _options.MAP[m];\n\t\t        });\n\t\t}\n\t\n\t\tfunction prepareKey(command, attributes, useKeyCommand) {\n\t\t    var result = empty, decode, stub;\n\t\t    if ((command === Command.elementOpen || command === Command.elementVoid)) {\n\t\n\t\t        if (attributes && attributes.hasOwnProperty(_options.staticKey)) {\n\t\t            decode = decodeAccessory(attributes[_options.staticKey] || makeKey());\n\t\t            delete attributes[_options.staticKey];\n\t\t        } else if (useKeyCommand) {\n\t\t            decode = {value: Command.getKey};\n\t\t        } else {\n\t\t            decode = {value: 'null'};\n\t\t        }\n\t\t        stub = (Object.keys(attributes).length > 0) ? ', ' : empty;\n\t\t        result = ', ' + decode.value + stub;\n\t\t    }\n\t\t    return result;\n\t\t}\n\t\n\t\tfunction prepareAttr(command, attributes) {\n\t\t    var result = empty, attr, decode, arrayStaticKey = false, isSkipped = false, skipCommand;\n\t\t    if ((command === Command.elementOpen || command === Command.elementVoid) && Object.keys(attributes).length > 0) {\n\t\t        if (attributes && attributes.hasOwnProperty(_options.staticArray)) {\n\t\t            arrayStaticKey = attributes[_options.staticArray] || makeKey();\n\t\t            staticArraysHolder[arrayStaticKey] = staticArraysHolder[arrayStaticKey] || {};\n\t\t            delete attributes[_options.staticArray];\n\t\t        }\n\t\n\t\t        if (attributes && attributes.hasOwnProperty(_options.skipAttr)) {\n\t\t            isSkipped = true;\n\t\t            skipCommand = Command.startSkipContent(decodeAccessory(attributes[_options.skipAttr], true).value);\n\t\t            delete attributes[_options.skipAttr];\n\t\t        }\n\t\n\t\t        result = arrayStaticKey || null;\n\t\t        for (var key in attributes) {\n\t\t            attr = attributes[key];\n\t\t            attr = (attr === null) ? key : ((attr === undefined) ? '' : attr);\n\t\t            decode = decodeAccessory(attr);\n\t\t            if (decode.isStatic && (_options.nonStaticAttributes.indexOf(key) === -1)) {\n\t\t                if (arrayStaticKey) {\n\t\t                    var value = formatText(attr);\n\t\t                    if (!staticArraysHolder[arrayStaticKey].hasOwnProperty(key)) {\n\t\t                        staticArraysHolder[arrayStaticKey][key] = value;\n\t\t                    } else if (staticArraysHolder[arrayStaticKey][key] !== value) {\n\t\t                        staticArraysHolder[arrayStaticKey][key] = removable;\n\t\t                        result += comma + key + '\", \"' + value + quote;\n\t\t                    }\n\t\t                } else\n\t\t                    result += comma + key + '\", \"' + formatText(attr) + quote;\n\t\t            } else {\n\t\t                result += comma + key + '\", ' + formatText(decode.value);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return {value: result, isSkipped: isSkipped, skip: skipCommand};\n\t\t}\n\t\n\t\tfunction unwrapStaticArrays(holder) {\n\t\t    var result = {}, obj, key;\n\t\t    for (var arrayName in holder) {\n\t\t        obj = holder[arrayName];\n\t\t        result[arrayName] = [];\n\t\n\t\t        for (key in obj)\n\t\t            if (obj[key] !== removable)\n\t\t                result[arrayName].push(quote + key + quote, quote + obj[key] + quote);\n\t\t    }\n\t\n\t\t    return result;\n\t\t}\n\t\n\t\tfunction decodeAttrs(obj) {\n\t\t    var result = ['{'];\n\t\t    for (var key in obj)\n\t\t        result.push(((result.length > 1) ? ',' : empty) + '\\'' + key + '\\'' + ':' + decodeAccessory(obj[key], true).value);\n\t\t    result.push('}');\n\t\n\t\t    return result.join(empty);\n\t\t}\n\t\n\t\tfunction camelCase(input) {\n\t\t    return input.replace(/\\s/g, '').replace(/-(.)/g, function (match, group1) {\n\t\t        return group1.toUpperCase();\n\t\t    });\n\t\t}\n\t\n\t\tfunction writeCommand(command, tag, attributes) {\n\t\t    if (attributes && attributes.ref) {\n\t\t        var refName = attributes.ref;\n\t\t        delete attributes.ref;\n\t\t    }\n\t\n\t\t    var strKey = prepareKey(command, attributes);\n\t\t    var strAttrs = prepareAttr(command, attributes);\n\t\n\t\t    if (refName) {\n\t\t        // i.e. ref[refName] = elementOpen(...)\n\t\t        command = Command.saveRef(camelCase(decodeAccessory(refName, true).value), command);\n\t\t    }\n\t\n\t\t    stack.push(command + tag + quote + strKey + strAttrs.value + Command.close);\n\t\n\t\t    // save skipped\n\t\t    if (strAttrs.isSkipped) {\n\t\t        stack.push(strAttrs.skip);\n\t\t        nestingLevelInfo.skip.push(nestingLevelInfo.level);\n\t\t    }\n\t\t}\n\t\n\t\tfunction writeText(text) {\n\t\t    text = formatText(text);\n\t\t    if (text.length > 0) {\n\t\t        var decode = decodeAccessory(text);\n\t\t        stack.push(Command.text + decode.value + Command.close);\n\t\t    }\n\t\t}\n\t\n\t\tfunction helperOpen(helperName, attrs) {\n\t\t    stack.push(Command.helpers + '[\"' + helperName + '\"](' + decodeAttrs(attrs) + ', function (' \n\t\t        + _options.parentParameterName + '){');\n\t\t}\n\t\n\t\tfunction helperClose() {\n\t\t    stack.push('}.bind(this));');\n\t\t}\n\t\n\t\tfunction isHelperTag(tagName) {\n\t\t    return localComponentNames.indexOf(tagName) !== -1 \n\t\t        || helpers.indexOf(tagName) !== -1\n\t\t        || tagName.indexOf(_options.helperPre) === 0;\n\t\t}\n\t\n\t\tfunction binderOpen(helperName, attrs) {\n\t\t    var fnName = helperName.replace(_options.binderPre, '');\n\t\t    stack.push(Command.binder + '(' + fnName + ',' + decodeAttrs(attrs) + ', function (' \n\t\t        + _options.parentParameterName + '){');\n\t\t}\n\t\n\t\tfunction binderClose() {\n\t\t    stack.push('}.bind(this));');\n\t\t}\n\t\n\t\tfunction isTagBinded(tagName) {\n\t\t    return tagName.indexOf(_options.binderPre) === 0;\n\t\t}\n\t\n\t\t// TODO: Clarify logic.\n\t\t// Seems like this method only opens state but named as 'CloseOpenState'\n\t\t// also seems like `isClosed` flags used only to detect elementVoid and it's a bit confusing\n\t\t// because sounds like it can be used to detect tags open or close state.\n\t\tfunction writeAndCloseOpenState(isClosed) {\n\t\t    var isShouldClose = true;\n\t\n\t\t    if (state.tag) {\n\t\t        var isRoot = isRootNode();\n\t\n\t\t        if (isHelperTag(state.tag)) { // helper case\n\t\t            helperOpen(state.tag, state.attributes);\n\t\t            isShouldClose = isClosed;\n\t\t        } else if (isTagBinded(state.tag)) {\n\t\t            binderOpen(state.tag, state.attributes);\n\t\t            isShouldClose = isClosed;\n\t\t        } else if (isClosed || _options.voidRequireTags.indexOf(state.tag) !== -1) { // void mode\n\t\t            writeCommand(Command.elementVoid, state.tag, state.attributes, isRoot);\n\t\t            nestingLevelInfo.level--;\n\t\t            isShouldClose = false;\n\t\t        } else if (state.tag !== _options.evaluate.name) { // standard mode\n\t\t            writeCommand(Command.elementOpen, state.tag, state.attributes, isRoot);\n\t\t        } // if we write code, do nothing\n\t\n\t\t        nestingLevelInfo.level++;\n\t\t    }\n\t\n\t\t    // clear builder state for next tag\n\t\t    state.tag = null;\n\t\t    state.attributes = {};\n\t\n\t\t    return isShouldClose; // should we close this tag: no if we have void element\n\t\t}\n\t\n\t\t/* public */\n\t\tfunction Builder(functionWrapper) {\n\t\t    wrapper = functionWrapper;\n\t\t    this.reset();\n\t\t}\n\t\n\t\tBuilder.prototype.reset = function () {\n\t\t    stack = [];\n\t\t    state = {\n\t\t        tag: null,\n\t\t        attributes: {}\n\t\t    };\n\t\t    staticArraysHolder = {};\n\t\t    nestingLevelInfo = {level: 0, skip: []};\n\t\t};\n\t\n\t\tBuilder.prototype.set = function (helpersKeys, localNames) {\n\t\t    helpers = helpersKeys;\n\t\t    localComponentNames = localNames || [];\n\t\t};\n\t\n\t\tBuilder.prototype.write = function (command) {\n\t\t    var tag;\n\t\t    switch (command.type) {\n\t\t        case Mode.Tag:\n\t\t            tag = command.name.replace('/', empty);\n\t\n\t\t            if (command.name.indexOf('/') === 0) {\n\t\n\t\t                // close tag case\n\t\t                if (writeAndCloseOpenState(true) && tag !== _options.evaluate.name) {\n\t\t                    nestingLevelInfo.level--;\n\t\n\t\t                    // write end skip functionality\n\t\t                    if (nestingLevelInfo.level === nestingLevelInfo.skip[nestingLevelInfo.skip.length - 1]) {\n\t\t                        stack.push(Command.endSkipContent);\n\t\t                        nestingLevelInfo.skip.pop();\n\t\t                    }\n\t\n\t\t                    if (isHelperTag(tag))\n\t\t                        helperClose();\n\t\t                    else if (isTagBinded(tag))\n\t\t                        binderClose();\n\t\t                    else\n\t\t                        writeCommand(Command.elementClose, tag);\n\t\t                }\n\t\t            } else {\n\t\t                // open tag case\n\t\t                writeAndCloseOpenState();\n\t\t                state.tag = tag;\n\t\t                state.attributes = {};\n\t\t            }\n\t\t            break;\n\t\t        case Mode.Attr: // push attribute in state\n\t\t            state.attributes[command.name] = command.data;\n\t\t            break;\n\t\t        case Mode.Text: // write text\n\t\t            tag = state.tag;\n\t\t            writeAndCloseOpenState();\n\t\t            if (tag === _options.evaluate.name) { // write code\n\t\t                stack.push(formatText(command.data));\n\t\t            } else {\n\t\t                writeText(command.data);\n\t\t            }\n\t\t            break;\n\t\t        case Mode.Comment: // write comments only in debug mode\n\t\t            if (_options.debug)\n\t\t                stack.push('\\n// ' + command.data.replace(_options.BREAK_LINE, ' ') + '\\n');\n\t\t            break;\n\t\t    }\n\t\t};\n\t\n\t\tBuilder.prototype.done = function () {\n\t\t    return wrapper(stack, unwrapStaticArrays(staticArraysHolder));\n\t\t};\n\t\n\t\tmodule.exports = Builder;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar _options = __webpack_require__(1);\n\t\n\t\tvar Command = { // incremental DOM commands\n\t\t    helpers: '_h',\n\t\t    binder: '_b',\n\t\t    elementOpen: '_o(\"',\n\t\t    elementClose: '_c(\"',\n\t\t    elementVoid: '_v(\"',\n\t\t    saveRef: function (name, command) {\n\t\t        return '_r[' + name + '] = ' + command;\n\t\t    },\n\t\t    text: '_t(',\n\t\t    close: ');\\n',\n\t\t    startSkipContent: function (flag) {\n\t\t        // compile static values\n\t\t        flag = (flag === '\"false\"') ? false : flag;\n\t\t        flag = (flag === '\"true\"') ? true : flag;\n\t\n\t\t        return 'if(' + flag + '){_l.skip();}else{';\n\t\t    },\n\t\t    endSkipContent: '}'\n\t\t};\n\t\n\t\tfunction createWrapper() {\n\t\t    var _library, _helpers, _fnName, _template;\n\t\t    var glue = '';\n\t\t    var eol = '\\n';\n\t\n\t\t    function wrapFn(body) {\n\t\t        var returnValue = eol + ' return _r;';\n\t\n\t\t        var prepareError = 'var TE=function(m,n,o){this.original=o;this.name=n;(o)?this.stack=this.original.stack:' +\n\t\t            'this.stack=null;this.message=o.message+m;};var CE=function(){};CE.prototype=Error.prototype;' +\n\t\t            'TE.prototype=new CE();TE.prototype.constructor=TE;';\n\t\n\t\t        if (_options.debug) {\n\t\t            return 'try {'\n\t\t                + body +\n\t\t                '} catch (err) {'\n\t\t                + prepareError +\n\t\t                'throw new TE(' + JSON.stringify(_template) + ', err.name, err);' +\n\t\t                '}'\n\t\t                + returnValue;\n\t\t        }\n\t\t        return body + returnValue;\n\t\t    }\n\t\n\t\t    function wrapper(stack, holder) {\n\t\t        var resultFn;\n\t\t        var variables = [\n\t\t                'var _o = _l.elementOpen;',\n\t\t                'var _c = _l.elementClose;',\n\t\t                'var _v = _l.elementVoid;',\n\t\t                'var _t = _l.text;',\n\t\t                'var _r = {};',\n\t\t                '_b = _b || function(fn, data, content){ return fn(data, content); };'\n\t\t            ].join(eol) + eol;\n\t\n\t\t        for (var key in holder) { // collect static arrays for function\n\t\t            if (holder.hasOwnProperty(key))\n\t\t                variables += 'var ' + key + '=[' + holder[key] + '];';\n\t\t        }\n\t\t        var body = variables + wrapFn(stack.join(glue));\n\t\n\t\t        if (_library) {\n\t\t            body = 'return function(' + _options.parameterName + ', ' + _options.renderContentFnName + ', _b){' + body + '};';\n\t\t            resultFn = (new Function('_l', '_h', body))(_library, _helpers);\n\t\t        } else {\n\t\t            resultFn = new Function(_options.parameterName, '_l', '_h', _options.renderContentFnName, '_b', body);\n\t\t        }\n\t\t        return resultFn;\n\t\t    }\n\t\n\t\t    wrapper.set = function (library, helpers, fnName, template) {\n\t\t        _library = library;\n\t\t        _helpers = helpers;\n\t\t        _fnName = fnName;\n\t\t        _template = template;\n\t\t    };\n\t\n\t\t    return wrapper;\n\t\t}\n\t\n\t\tmodule.exports = {\n\t\t    createWrapper: createWrapper,\n\t\t    Command: Command\n\t\t};\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _ = __webpack_require__(1);\n\tvar core = __webpack_require__(13);\n\tvar Config = __webpack_require__(9);\n\t\n\tfunction binder(component, props, content) {\n\t\n\t    var BaseView = __webpack_require__(14);\n\t    \n\t    props = props || {};\n\t    props.key = props.key || props.id;\n\t\n\t    // If BaseView instance was passed\n\t    if (component instanceof BaseView) {\n\t        component.props.set(_.omit(props, Config.ViewOptions), {silent:true});\n\t        return component.render();\n\t    }\n\t\n\t    // If component with passed key already registered\n\t    var registrationId = 'view-key-' + props.key;\n\t    var registeredComponent = core.get( registrationId );\n\t\n\t    if (registeredComponent) {\n\t        registeredComponent.props.set(_.omit(props, Config.ViewOptions), {silent:true});\n\t        return registeredComponent.render();\n\t    }\n\t\n\t    // If new component was passed\n\t    var newComponent = _.isFunction(component) ? new component(props, content) : component;\n\t    if (newComponent instanceof BaseView) {\n\t        return newComponent.render();\n\t    }\n\t\n\t    return newComponent;\n\t}\n\t\n\tmodule.exports = binder;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar _ = __webpack_require__(1);\n\tvar Dispatcher = __webpack_require__(6);\n\tvar InternalEvents = __webpack_require__(9).Events;\n\t\n\tvar modules = {};\n\t\n\tvar defaults = {\n\t    debug: false,\n\t    parameterName: 'data',\n\t    viewAttributes: {\n\t        'data-role': 'view'\n\t    }\n\t};\n\t\n\tfunction Core(Dispatcher) {\n\t    this.options = defaults;\n\t\n\t    Dispatcher.subscribe(InternalEvents.REGISTER, this.register, this);\n\t    Dispatcher.subscribe(InternalEvents.UNREGISTER, this.unregister, this);\n\t}\n\t\n\t\n\t/**\n\t *  Override RAD.js default settings\n\t *\n\t *  @param {Object} options\n\t *  @param {string} [options.parameterName = model] - Sets the name of the argument to be passed to the template function.\n\t *  @param {boolean} [options.debug = false]        - Enable console logging\n\t */\n\tCore.prototype.setOptions = function(options) {\n\t    _.extend(this.options, options);\n\t};\n\t\n\tCore.prototype.get = function (id) {\n\t    return modules[id];\n\t};\n\t\n\tCore.prototype.getAll = function () {\n\t    return _.clone(modules);\n\t};\n\t\n\tCore.prototype.register = function (id, obj) {\n\t    if (modules[id]) {\n\t        throw new Error('Such module ID: '+id+' already registered');\n\t    }\n\t    modules[id] = obj;\n\t};\n\t\n\tCore.prototype.unregister = function (id) {\n\t    if (modules[id]) {\n\t        delete modules[id];\n\t    }\n\t};\n\t\n\t\n\tmodule.exports = new Core( Dispatcher );\n\t\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _ = __webpack_require__(1);\n\tvar Backbone = __webpack_require__(5);\n\t\n\tvar IncrementalDOM = __webpack_require__(4);\n\tvar Dispatcher = __webpack_require__(6);\n\tvar Config = __webpack_require__(9);\n\tvar Events = Config.Events;\n\tvar Core = __webpack_require__(13);\n\tvar defaultAttributes = Core.options.viewAttributes;\n\tvar register = Core.register;\n\tvar unregister = Core.unregister;\n\t\n\tfunction isRendering() {\n\t    return !!IncrementalDOM.currentElement();\n\t}\n\t\n\tfunction makeId(options) {\n\t    if (options && options.key) {\n\t        return 'view-key-' + options.key;\n\t    }\n\t    return _.result(options, 'id', _.uniqueId('view-'));\n\t}\n\t\n\tfunction compileTemplate(template) {\n\t    return typeof template === 'string' ? RAD.template(template) : template;\n\t}\n\t\n\tfunction hasKey(node) {\n\t    return node.__incrementalDOMData && node.__incrementalDOMData.key;\n\t}\n\t\n\tvar BaseView = function(options) {\n\t    this.viewId = makeId(options);\n\t    this.refs = {};\n\t\n\t    var Props = this.propsModel || Backbone.Model;\n\t    this.props = new Props( _.omit(options, Config.ViewOptions) );\n\t\n\t    this._bindChannels();\n\t    Backbone.View.apply(this, arguments);\n\t    this.template = compileTemplate(this.template);\n\t    this.bindRender(this.props, 'change');\n\t\n\t    register(this.getID(), this);\n\t};\n\t\n\tBaseView.prototype = _.create(Backbone.View.prototype, {\n\t    _bindChannels: function() {\n\t        var id = this.getID();\n\t        var attachMsg = id + ':' + Events.ATTACH;\n\t        var detachMsg = id + ':' + Events.DETACH;\n\t\n\t        this.subscribe(id, this.onReceiveMsg, this);\n\t        this.subscribe(attachMsg, this.onAttach, this);\n\t        this.subscribe(detachMsg, this.onDetach, this);\n\t\n\t        if (isRendering()) {\n\t            this.subscribe(detachMsg, this.destroy, this);\n\t        }\n\t    },\n\t\n\t    setElement: function(el) {\n\t        var $el = el instanceof Backbone.$ ? el : Backbone.$(el);\n\t        var viewId = $el.attr(Config.Attributes.ID);\n\t\n\t        if (viewId && viewId !== this.getID()) {\n\t            throw new Error('You cannot setElement which is used by another View.');\n\t        } else {\n\t            Backbone.View.prototype.setElement.call(this, $el);\n\t        }\n\t    },\n\t\n\t    getID: function() {\n\t        return this.viewId;\n\t    },\n\t\n\t    getTemplateData: function() {\n\t        return {\n\t            collection: this.collection && this.collection.toJSON(),\n\t            model: this.model && this.model.toJSON(),\n\t            props: this.props.toJSON()\n\t        };\n\t    },\n\t\n\t    bindRender: function(target, events) {\n\t        this.listenTo(target, events, this.render);\n\t    },\n\t\n\t    render: function () {\n\t        if (isRendering()) {\n\t            this._render();\n\t        } else {\n\t            this._renderOuter();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _renderOuter: function() {\n\t        var self = this;\n\t        IncrementalDOM.patchOuter(this.el, function() {\n\t            if (hasKey(self.el)) {\n\t                self._render();\n\t            } else {\n\t                self.el.setAttribute('key', self.getID());\n\t                self._render();\n\t                self.el.removeAttribute('key');\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    _render: function () {\n\t        if (this.onBeforeRender() === false) {\n\t            return this._skip();\n\t        }\n\t\n\t        this._viewElOpen();\n\t        this._renderTemplate();\n\t        this._viewElClose();\n\t\n\t        this.onRender();\n\t        return this;\n\t    },\n\t\n\t    _renderTemplate: function() {\n\t        if (typeof this.template === 'function') {\n\t            this.refs = this.template(this.getTemplateData());\n\t        } else {\n\t            IncrementalDOM.skip();\n\t        }\n\t    },\n\t\n\t    _skip: function() {\n\t        this._viewElOpen();\n\t        IncrementalDOM.skip();\n\t        this._viewElClose();\n\t        return this;\n\t    },\n\t    _viewElOpen: function () {\n\t        IncrementalDOM.elementOpenStart(this.el.tagName.toLowerCase(), this.getID());\n\t        this._setElAttributes();\n\t        IncrementalDOM.elementOpenEnd();\n\t    },\n\t    _viewElClose: function () {\n\t        var el = IncrementalDOM.elementClose(this.el.tagName.toLowerCase());\n\t        if (this.el !== el) {\n\t            this.setElement(el);\n\t        }\n\t    },\n\t    _setElAttributes: function() {\n\t        var attributes = _.extend({}, defaultAttributes, _.result(this, 'attributes', {}));\n\t        attributes.id = _.result(this, 'id');\n\t        attributes.class = _.result(this, 'className');\n\t        attributes[Config.Attributes.ID] = this.getID();\n\t\n\t        _.each(attributes, function (value, name) {\n\t            IncrementalDOM.attr(name, value);\n\t        });\n\t    },\n\t\n\t    _removeElement: function () {\n\t        this.$el.remove();\n\t        this.publish(Events.NODE_REMOVED, this.el);\n\t        return this;\n\t    },\n\t\n\t    destroy: function () {\n\t        this.unsubscribe(null, null, this);\n\t        unregister(this.getID());\n\t\n\t        this.remove();\n\t        this.onDestroy();\n\t\n\t        this.off();\n\t        this.undelegateEvents();\n\t    },\n\t    subscribe: function(channel, callback, context) {\n\t        return Dispatcher.subscribe(channel, callback, context || this);\n\t    },\n\t    unsubscribe: function(channel, callback, context) {\n\t        return Dispatcher.unsubscribe(channel, callback, context || this);\n\t    },\n\t    publish: function() {\n\t        return Dispatcher.publish.apply(Dispatcher, arguments);\n\t    }\n\t});\n\t\n\t_.extend(BaseView.prototype, {\n\t    onReceiveMsg:   function () {},\n\t    onBeforeRender: function () {},\n\t    onRender:       function () {},\n\t    onAttach:       function () {},\n\t    onDetach:       function () {},\n\t    onDestroy:      function () {}\n\t});\n\t\n\tBaseView.extend = function(protoProps, staticProps) {\n\t    return Backbone.View.extend.apply(this, arguments)\n\t};\n\t\n\tmodule.exports = BaseView;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(1);\n\tvar IDOM_DATA = '__incrementalDOMData';\n\tvar RENDER_DATA = '__renderData';\n\t\n\t\n\tfunction getNodeData(el) {\n\t    return el[IDOM_DATA];\n\t}\n\t\n\tfunction setRenderData(node, options) {\n\t    if (!node[RENDER_DATA]) {\n\t        node[RENDER_DATA] = {};\n\t    }\n\t    return _.extend(node[RENDER_DATA], options);\n\t}\n\t\n\tfunction getRenderData(node) {\n\t    return node[RENDER_DATA] || setRenderData(node, {});\n\t}\n\t\n\tfunction toArray(args, startIndex) {\n\t    return Array.prototype.slice.call(args, startIndex || 0);\n\t}\n\t\n\tmodule.exports = {\n\t    getNodeData: getNodeData,\n\t    getRenderData: getRenderData,\n\t    setRenderData: setRenderData,\n\t    toArray: toArray\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(1);\n\tvar publish = __webpack_require__(6).publish;\n\tvar iDOM = __webpack_require__(4);\n\tvar Events = __webpack_require__(9).Events;\n\tvar utils = __webpack_require__(15);\n\tvar transition = __webpack_require__(17);\n\tvar initTransitionOptions = __webpack_require__(21);\n\t\n\tvar RenderStatus = {\n\t    ENTER: 'enter',\n\t    LEAVE: 'leave',\n\t    DONE: 'done'\n\t};\n\t\n\tvar isPlaceholder = false;\n\t\n\tfunction createPlaceholder(node) {\n\t    var key = utils.getNodeData(node).key;\n\t    var tagName = node.tagName.toLowerCase();\n\t    isPlaceholder = true;\n\t    iDOM.elementOpen.apply(null, [tagName, key, null].concat( utils.getNodeData(node).attrsArr ));\n\t    iDOM.skip();\n\t    iDOM.elementClose(tagName);\n\t    isPlaceholder = false;\n\t}\n\t\n\tfunction alignContent(children, position, key) {\n\t    var length = children.length;\n\t    var node = children[position];\n\t\n\t    while (position < length && node && utils.getNodeData(node).key !== key) {\n\t        createPlaceholder(node);\n\t        node = children[++position];\n\t    }\n\t\n\t    return position;\n\t}\n\t\n\tfunction renderStart(renderData) {\n\t    var position = renderData.position;\n\t    var children = renderData.children;\n\t    var keyMap = renderData.keyMap;\n\t    var level = 0;\n\t    var childLevel = 1;\n\t    var isNewChild = false;\n\t\n\t    function beforeCreate(tagName, key) {\n\t        if (isPlaceholder) {\n\t            return;\n\t        }\n\t\n\t        var isChild = (++level) === childLevel;\n\t        isNewChild = false;\n\t\n\t        if (isChild) {\n\t            // Check if opened Element is already present in the list.\n\t            if (keyMap[key]) {\n\t                // If so then align its position with current content and return new position\n\t                position = alignContent(children, position, key);\n\t            } else {\n\t                isNewChild = true;\n\t            }\n\t            position++;\n\t        }\n\t    }\n\t    function afterCreate(tagName, key) {\n\t        if (isPlaceholder) {\n\t            return;\n\t        }\n\t\n\t        var isChild = level === childLevel;\n\t        var node = iDOM.currentElement();\n\t\n\t        if (isChild) {\n\t            renderData.keysRendered[key] = node;\n\t        }\n\t        if (isNewChild) {\n\t            children.splice(position - 1, 0, node);\n\t            keyMap[key] = node;\n\t            renderData.keysToShow[key] = node;\n\t        }\n\t\n\t        renderData.position = position;\n\t    }\n\t\n\t    iDOM.events.on('elementOpen:before', beforeCreate, renderData);\n\t    iDOM.events.on('elementOpen:after', afterCreate, renderData);\n\t    iDOM.events.on('elementClose:after', function() {\n\t        if (!isPlaceholder) {\n\t            level--;\n\t        }\n\t    }, renderData);\n\t\n\t    var elementOpenKey;\n\t    iDOM.events.on('elementOpenStart:before', function(tagName, key) {\n\t        if (!isPlaceholder) {\n\t            elementOpenKey = key;\n\t            beforeCreate(tagName, key);\n\t        }\n\t    }, renderData);\n\t\n\t    iDOM.events.on('elementOpenEnd:after', function(tagName, key) {\n\t        if (!isPlaceholder) {\n\t            afterCreate(tagName, elementOpenKey);\n\t        }\n\t    }, renderData);\n\t}\n\t\n\tfunction renderStop(renderData) {\n\t    iDOM.events.off(null, null, renderData);\n\t\n\t    alignContent(renderData.children, renderData.position);\n\t}\n\t\n\tfunction doTransition(renderData, runner) {\n\t    var rootEl = renderData.rootEl;\n\t    var activeKeys = utils.getNodeData(rootEl).keyMap;\n\t    var transitionOptions = initTransitionOptions(renderData.attrs);\n\t    var children = Array.prototype.slice.call(rootEl.children);\n\t\n\t    if (!renderData.applyAnimation) {\n\t        transitionOptions.enterTimeout = transitionOptions.leaveTimeout = 0;\n\t    }\n\t\n\t    _.each(children, function(node) {\n\t        var key = utils.getNodeData(node).key;\n\t        var render = utils.getRenderData(node);\n\t\n\t        if (!renderData.keysRendered[key]) {\n\t            if (render.status !== RenderStatus.LEAVE) {\n\t                render.status = RenderStatus.LEAVE;\n\t                transition.leave(node, transitionOptions, function() {\n\t                    render.status = RenderStatus.DONE;\n\t                    delete activeKeys[key];\n\t                    publish(Events.NODE_REMOVED, node, runner);\n\t                }, runner);\n\t           }\n\t        } else if (renderData.keysToShow[key] || render.status === RenderStatus.LEAVE) {\n\t            if (render.status !== RenderStatus.ENTER) {\n\t            render.status = RenderStatus.ENTER;\n\t                transition.enter(node, transitionOptions, function () {\n\t                    render.status = RenderStatus.DONE;\n\t                }, runner);\n\t            }\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    start: renderStart,\n\t    stop: renderStop,\n\t    doTransition: doTransition\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar AnimationEnd = __webpack_require__(18);\n\tvar TransitionEnd = __webpack_require__(19);\n\tvar utilsDOM = __webpack_require__(8);\n\tvar sep = ' ';\n\t\n\tfunction clearTransitionTimeout(node) {\n\t    if (node.__transitionId) {\n\t        clearTimeout(node.__transitionId);\n\t        node.__transitionId = null;\n\t    }\n\t}\n\t\n\tfunction setTransitionTimeout(node, cb, timeout) {\n\t    node.__transitionId = setTimeout(function () {\n\t        cb(node);\n\t    }, timeout);\n\t}\n\t\n\tfunction hasActiveTransition(node) {\n\t    return node.__transitionId && node.stopActiveTransition;\n\t}\n\t\n\tfunction transition(node, options, timeout, callback) {\n\t    var transitionEnd = new TransitionEnd(node);\n\t    var animationEnd = new AnimationEnd(node);\n\t    var triggers = [\n\t        options.animationEnter,\n\t        options.animationLeave,\n\t        options.enterClass,\n\t        options.leaveClass,\n\t        options.activeClass\n\t    ].join(sep);\n\t\n\t    node.stopActiveTransition = function () {\n\t        clearTransitionTimeout(node);\n\t        transitionEnd.unbindAll();\n\t        animationEnd.unbindAll();\n\t        utilsDOM.removeClass(node, triggers);\n\t    };\n\t\n\t    function done() {\n\t        node.stopActiveTransition();\n\t        callback && callback(node);\n\t    }\n\t\n\t    function onTransitionEnd(e) {\n\t        if (e.target === node) {\n\t            done();\n\t        }\n\t    }\n\t\n\t    // handle both animation and transition\n\t    transitionEnd.bind(onTransitionEnd);\n\t    animationEnd.bind(onTransitionEnd);\n\t\n\t    if (!timeout) {\n\t        return done();\n\t    }\n\t\n\t    setTransitionTimeout(node, done, timeout);\n\t\n\t    // Run transition\n\t    utilsDOM.addClass(node, options.activeClass);\n\t}\n\t\n\tfunction transitionLeave(node, options, callback, runner) {\n\t    if (hasActiveTransition(node)) {\n\t        node.stopActiveTransition();\n\t    }\n\t\n\t    utilsDOM.addClass(node, [options.leaveClass].join(sep));\n\t    utilsDOM.removeClass(node, options.enterClass);\n\t\n\t    runner.push(function () {\n\t        utilsDOM.addClass(node, [options.animationLeave].join(sep));\n\t        transition(node, options, options.leaveTimeout, function (node) {\n\t            node.parentNode && node.parentNode.removeChild(node);\n\t            callback && callback();\n\t        });\n\t    });\n\t}\n\t\n\tfunction transitionEnter(node, options, callback, runner) {\n\t    if (hasActiveTransition(node)) {\n\t        node.stopActiveTransition();\n\t    }\n\t\n\t    utilsDOM.addClass(node, [options.enterClass].join(sep));\n\t    utilsDOM.removeClass(node, options.leaveClass);\n\t\n\t    runner.push(function () {\n\t        utilsDOM.addClass(node, [options.animationEnter].join(sep));\n\t        transition(node, options, options.enterTimeout, callback);\n\t    });\n\t}\n\t\n\tmodule.exports.enter = transitionEnter;\n\tmodule.exports.leave = transitionLeave;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar TransitionEnd = __webpack_require__(19);\n\tvar whichCssEvent = __webpack_require__(20);\n\tvar ANIMATION_DATA = '__animationData';\n\t\n\tfunction AnimationEnd(el) {\n\t    TransitionEnd.call(this, el);\n\t}\n\t\n\tAnimationEnd.prototype = Object.create(TransitionEnd.prototype);\n\tAnimationEnd.prototype.constructor = AnimationEnd;\n\t\n\tAnimationEnd.prototype._initData = function() {\n\t    this.el[ANIMATION_DATA] = {\n\t        eventName: whichCssEvent({\n\t            \"animation\"      : \"animationend\",\n\t            \"MozAnimation\"   : \"animationend\",\n\t            \"WebkitAnimation\": \"webkitAnimationEnd\"\n\t        }),\n\t        callbacks: []\n\t    };\n\t};\n\t\n\tAnimationEnd.prototype._getData = function() {\n\t    return this.el[ANIMATION_DATA];\n\t};\n\t\n\tmodule.exports = AnimationEnd;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar whichCssEvent = __webpack_require__(20);\n\tvar TRANSITION_DATA = '__transitionData';\n\t\n\tfunction TransitionEnd(el) {\n\t    this.el = el && (el[0] || el);\n\t\n\t    if (!(this.el instanceof HTMLElement)) {\n\t        throw new Error('HTMLElement must be passed as an argument');\n\t    }\n\t\n\t    if (!this._getData()) {\n\t        this._initData();\n\t    }\n\t}\n\t\n\tTransitionEnd.prototype._initData = function() {\n\t    this.el[TRANSITION_DATA] = {\n\t        eventName: whichCssEvent({\n\t            'transition'      :'transitionend',\n\t            'MozTransition'   :'transitionend',\n\t            'WebkitTransition':'webkitTransitionEnd'\n\t        }),\n\t        callbacks: []\n\t    };\n\t};\n\t\n\tTransitionEnd.prototype._getData = function() {\n\t    return this.el[TRANSITION_DATA];\n\t};\n\t\n\tTransitionEnd.prototype.bind = function(fn) {\n\t    var data = this._getData();\n\t\n\t    if (data.callbacks.indexOf(fn) === -1) {\n\t        data.callbacks.push(fn);\n\t        this.el.addEventListener(data.eventName, fn, false);\n\t    }\n\t};\n\t\n\tTransitionEnd.prototype.unbind = function(fn) {\n\t    var data = this._getData(),\n\t        index = data.callbacks.indexOf(fn);\n\t\n\t    if (index !== -1) {\n\t        data.callbacks.splice(index, 1);\n\t        this.el.removeEventListener(data.eventName, fn, false);\n\t    }\n\t};\n\t\n\tTransitionEnd.prototype.unbindAll = function() {\n\t    this._getData().callbacks.forEach(this.unbind, this);\n\t};\n\t\n\t\n\tmodule.exports = TransitionEnd;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function whichCssEvents(eventsMap) {\n\t    var name,\n\t        testEl = document.createElement(\"xelement\");\n\t\n\t    for (name in eventsMap){\n\t        if (testEl.style[name] !== undefined) {\n\t            return eventsMap[name];\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar DEFAULT_LEAVE_CLASS = 'leave';\n\tvar DEFAULT_ENTER_CLASS = 'enter';\n\tvar DEFAULT_ACTIVE_CLASS = 'animated';\n\tvar DEFAULT_TIMEOUT = 3500;\n\t\n\t\n\tmodule.exports = function (attrs) {\n\t    var enterTimeout = parseInt(attrs.enterTimeout, 10);\n\t    var leaveTimeout = parseInt(attrs.leaveTimeout, 10);\n\t    var animationName = attrs.name || attrs.animationName;\n\t\n\t    return {\n\t        animationEnter: attrs.animationEnter || animationName,\n\t        animationLeave: attrs.animationLeave || animationName,\n\t        initialAnimation: attrs.initialAnimation,\n\t\n\t        enterClass: attrs.enterClass || DEFAULT_ENTER_CLASS,\n\t        leaveClass: attrs.leaveClass || DEFAULT_LEAVE_CLASS,\n\t\n\t        enterTimeout: isNaN(enterTimeout) ? DEFAULT_TIMEOUT : enterTimeout,\n\t        leaveTimeout: isNaN(leaveTimeout) ? DEFAULT_TIMEOUT : leaveTimeout,\n\t\n\t        activeClass: attrs.activeClass || DEFAULT_ACTIVE_CLASS\n\t    };\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tfunction Runner(name) {\n\t    this.name = name;\n\t    this.callbacks = [];\n\t}\n\t\n\tRunner.prototype.push = function (callback) {\n\t    this.callbacks.push(callback);\n\t};\n\t\n\tRunner.prototype.execute = function () {\n\t    for (var i = this.callbacks.length - 1; i >= 0; i--)\n\t        this.callbacks.pop()();\n\t};\n\t\n\tvar query = {\n\t\n\t    runners: {},\n\t\n\t    create: function (options) {\n\t        var delay;\n\t\n\t        // extract delay value\n\t        if (options && options.hasOwnProperty('delay')) {\n\t            delay = parseInt(options.delay, 10) || 0;\n\t        }\n\t\n\t        // generate name for runner\n\t        var name = \"name_\" + Math.random().toString(16).slice(2);\n\t        if (options && options.hasOwnProperty('groupName')) {\n\t            name = options.groupName;\n\t        }\n\t\n\t        // push runner to query\n\t        if (!this.runners.hasOwnProperty(name)) {\n\t            this.runners[name] = [];\n\t        }\n\t\n\t        var runner = new Runner(name);\n\t        this.runners[name].push(runner);\n\t        this.runners[name].delay = delay;\n\t\n\t        return runner;\n\t    },\n\t\n\t    run: function (name) {\n\t        var runners = this.runners[name];\n\t        if (runners) {\n\t            var delay = this.runners[name].delay;\n\t\n\t            function execute() {\n\t                for (var i = runners.length - 1; i >= 0; i--) {\n\t                    runners.pop().execute();\n\t                }\n\t            }\n\t\n\t            if (delay !== undefined) {\n\t                setTimeout(execute, delay);\n\t            } else {\n\t                execute();\n\t            }\n\t            this.runners[name] = [];\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = query;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _ = __webpack_require__(1);\n\t\n\tvar Module = __webpack_require__(24);\n\tvar Events = __webpack_require__(9).Events;\n\tvar Attrs = __webpack_require__(9).Attributes;\n\t\n\tvar LayoutManager = Module.extend({\n\t    activePatches: [],\n\t\n\t    initialize: function() {\n\t        this.subscribe(Events.PATCH_START, this.onPatchStart, this);\n\t        this.subscribe(Events.PATCH_END, this.onPatchEnd, this);\n\t        this.subscribe(Events.NODE_REMOVED, this.onNodeRemove, this);\n\t    },\n\t\n\t    onNodeRemove: function(node) {\n\t        var ids = this.getChildIDs(node);\n\t\n\t        // Check that we are not trying to remove are still active children.\n\t        // It is possible that Parent was removed from the DOM but its children should stay in DOM (was reattached).\n\t        if (this.activeViews) {\n\t            ids = ids.filter(function(id) {\n\t                return this.activeViews.indexOf(id) < 0;\n\t            }, this);\n\t        }\n\t\n\t        if (node.hasAttribute(Attrs.ID)) {\n\t            ids.unshift(node.getAttribute(Attrs.ID));\n\t        }\n\t\n\t        this.publishEvent(ids, Events.DETACH);\n\t    },\n\t\n\t    isOnPage: function(node) {\n\t        return document.body.contains(node);\n\t    },\n\t\n\t    onPatchStart: function(node) {\n\t        if (!this.isOnPage(node)) {\n\t            return;\n\t        }\n\t\n\t        var views = this.getChildIDs(node);\n\t\n\t        if (node.hasAttribute(Attrs.ID)) {\n\t            views.unshift(node.getAttribute(Attrs.ID));\n\t        }\n\t\n\t        this.activePatches.push({\n\t            node: node,\n\t            views: views\n\t        });\n\t    },\n\t\n\t    onPatchEnd: function(node) {\n\t        if (!this.isOnPage(node)) {\n\t            return;\n\t        }\n\t\n\t        var patchData = this.activePatches.pop();\n\t\n\t        if (patchData.node !== node) {\n\t            throw new Error('Wrong patch order');\n\t        }\n\t\n\t        this.refreshLayout(patchData);\n\t    },\n\t\n\t    getChildIDs: function (el) {\n\t        var els = el.querySelectorAll('['+Attrs.ID+']');\n\t        var ids = [];\n\t        var index = 0;\n\t\n\t        for (index; index < els.length; index++) {\n\t            ids[index] = els[index].getAttribute(Attrs.ID);\n\t        }\n\t\n\t        return ids;\n\t    },\n\t\n\t    refreshLayout: function(patchData) {\n\t        var node = patchData.node;\n\t        var viewsBefore = patchData.views;\n\t        var viewsAfter = this.getChildIDs(node);\n\t\n\t        if (node.hasAttribute(Attrs.ID)) {\n\t            viewsAfter.unshift(node.getAttribute(Attrs.ID));\n\t        }\n\t\n\t        this.activeViews = viewsAfter;\n\t        var detachedViews = _.difference(viewsBefore, viewsAfter);\n\t        this.publishEvent(detachedViews, Events.DETACH);\n\t\n\t        var attachedViews = _.difference(viewsAfter, viewsBefore);\n\t        this.publishEvent(attachedViews, Events.ATTACH);\n\t        this.activeViews = null;\n\t    },\n\t\n\t    publishEvent: function(subscribers, event) {\n\t        subscribers.forEach(function(id){\n\t            this.publish(id + ':' + event);\n\t        }, this);\n\t    }\n\t});\n\t\n\tmodule.exports = new LayoutManager();\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar _ = __webpack_require__(1);\n\tvar Backbone = __webpack_require__(5);\n\tvar Dispatcher = __webpack_require__(6);\n\t\n\tvar moduleOptions = ['channel', 'id'];\n\t\n\tfunction Module(options) {\n\t    this.cid = _.uniqueId('module');\n\t\n\t    _.extend(this, _.pick(options, moduleOptions));\n\t\n\t    this.id = _.result(this, 'id', this.cid);\n\t    this.initialize.apply(this, arguments);\n\t\n\t    if (this.channel) {\n\t        this.subscribe(this.channel, this.onReceiveMsg, this);\n\t    }\n\t}\n\t\n\t_.extend( Module.prototype, Dispatcher, {\n\t    initialize: function () {},\n\t    onReceiveMsg: function () {},\n\t\n\t    destroy: function () {\n\t        this.unsubscribe(null,null, this);\n\t    }\n\t});\n\t\n\tModule.extend = Backbone.View.extend;\n\t\n\tmodule.exports = Module;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar _ = __webpack_require__(1);\n\tvar core = __webpack_require__(13);\n\tvar Module = __webpack_require__(24);\n\tvar iDOM = __webpack_require__(4);\n\tvar renderView = __webpack_require__(12);\n\t\n\tvar Navigator = Module.extend({\n\t\n\t    initialize: function() {\n\t        this.subscribe('navigation:show', this.navigateView, this);\n\t        this.subscribe('navigation:back', this.navigateBack, this);\n\t\n\t        // Old API support\n\t        this.subscribe('navigation.show', this.navigateView, this);\n\t        this.subscribe('navigation.back', this.navigateBack, this);\n\t    },\n\t\n\t    /**\n\t     * @description\n\t     * Allow to navigate View with transition effects\n\t     *\n\t     * @param {Object} data\n\t     * @param {(String|HTMLElement)}    data.container          - CSS selector or HTMLElement where to attach new View\n\t     * @param {String}                  data.content            - View ID to show\n\t     *\n\t     * @param {String}                  [data.animation]        - animation name which will be applied for transition\n\t     * @param {Object}                  [data.extras]           - extra data that you can pass to the new View\n\t     *\n\t     * @callback doneCallback\n\t     * @param {doneCallback}            [data.callback]         - fires on transition end\n\t     */\n\t    navigateView: function(data) {\n\t        data = data || {};\n\t\n\t        var container = this.getEl(data.container);\n\t\n\t        if (!container) {\n\t            throw new Error('Cannot find container el: ' + data.container);\n\t        }\n\t\n\t        this.patchContainer(container, this.getContent(data.content), data.options);\n\t    },\n\t\n\t    navigateBack: function (data) {\n\t        data.direction = 'back';\n\t        this.navigateView(data);\n\t    },\n\t\n\t    getEl: function(selector) {\n\t        return _.isString(selector) ? document.querySelector(selector) : selector;\n\t    },\n\t\n\t    patchContainer: function(container, view, options) {\n\t        iDOM.patch(container, function() {\n\t            if (view) {\n\t                renderView(view, options);\n\t            }\n\t        });\n\t    },\n\t\n\t    getContent: function(content) {\n\t        if (_.isString(content)) {\n\t            return core.get(content);\n\t        }\n\t\n\t        return content;\n\t    }\n\t});\n\t\n\tmodule.exports = new Navigator();\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports.template = __webpack_require__(10);\n\tmodule.exports.IncrementalDOM = __webpack_require__(4);\n\tmodule.exports.TransitionEnd = __webpack_require__(19);\n\tmodule.exports.AnimationEnd = __webpack_require__(18);\n\tmodule.exports.DOM = __webpack_require__(8);\n\t\n\t// todo remove binder after redesign component constructor\n\tmodule.exports.ITemplate = __webpack_require__(11);\n\tmodule.exports.binder = __webpack_require__(12);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** rad.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b8d3facc6683b0dd4674\n **/","\"use strict\";\nvar _ = require('underscore');\n\n// Init plugins\nrequire('./plugins');\n\n/**\n *\n * RAD namespace.\n * @namespace\n */\n\nvar RAD = {};\n\nRAD.core = require('./core');\nRAD.utils = require('./utils');\nRAD.template = require('./template');\nRAD.View = require('./blanks/view');\nRAD.Module = require('./blanks/module');\n\n// Extend with Dispatcher API: publish, subscribe, unsubscribe\n_.extend(RAD, require('./core/dispatcher'));\n\nmodule.exports = RAD;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/rad.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"_\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\",\"amd\":\"underscore\"}\n ** module id = 1\n ** module chunks = 0\n **/","require('./transition_group');\nrequire('./layout_manager');\nrequire('./navigator');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar IncrementalDOM = require('../../template/idom');\nvar template = require('../../template');\nvar utils = require('./utils');\nvar contentHandler = require('./contentHandler');\nvar iTemplate = require('idom-template');\nvar RunnerQuery = require('./runner');\n\nvar reservedAttrs = [\n    'name', // deprecated\n    'tagName',\n    'key',\n\n    'initialAnimation',\n    'animationName',\n    'animationEnter',\n    'animationLeave',\n    'enterTimeout',\n    'leaveTimeout',\n\n    'enterClass',\n    'leaveClass',\n    'activeClass',\n    'delay',\n    'groupName'\n];\n\nfunction rootElementOpen(options) {\n    IncrementalDOM.elementOpenStart(options.tagName || 'div', options.key);\n\n    _.each(_.omit(options, reservedAttrs), function (value, name) {\n        IncrementalDOM.attr(name, value);\n    });\n\n    var el = IncrementalDOM.elementOpenEnd();\n\n    if (el.__firstRender === undefined) {\n        el.__firstRender = true;\n    }\n\n    return el;\n}\n\nfunction rootElementClose(attrs) {\n    var el = IncrementalDOM.elementClose(attrs.tagName);\n    el.__firstRender = false;\n    return el;\n}\n\nfunction initRenderData(rootEl, attrs) {\n    return {\n        rootEl: rootEl,\n        attrs: attrs,\n        children: utils.toArray(rootEl.children),\n        keyMap: _.clone(utils.getNodeData(rootEl).keyMap) || {},\n        keysRendered: {},\n        keysToShow: {},\n        position: 0,\n        firstRender: rootEl.__firstRender,\n        applyAnimation: !rootEl.__firstRender || attrs.initialAnimation !== 'none'\n    };\n}\n\niTemplate.registerHelper('i-transition', function(options, renderContent) {\n    if (options.name) {\n        console.warn('Warning: `name` is deprecated attribute for transitionGroup, use `animationName` instead');\n    }\n\n    var rootEl = rootElementOpen(options);\n    var renderData = initRenderData(rootEl, options);\n\n    contentHandler.start(renderData);\n    renderContent();\n    contentHandler.stop(renderData);\n    rootElementClose(options);\n\n    var runner = RunnerQuery.create(options);\n    contentHandler.doTransition(renderData, runner);\n    RunnerQuery.run(runner.name);\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/index.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _ = require('underscore');\nvar Backbone = require('backbone');\nvar publish = require('../core/dispatcher').publish;\nvar incrementalDOM = require('incremental-dom');\nvar attributeSetters = incrementalDOM.attributes;\nvar UtilsDOM = require('./../utils/DOM_Utils');\nvar Events = require('../config').Events;\n\n// Sett HTMlInput [checked], [disabled] and [readonly] attributes as properties\nfunction setBooleanAttr(el, attr, value) {\n    el[attr] = !!value;\n}\n\nattributeSetters.checked  = setBooleanAttr;\nattributeSetters.disabled = setBooleanAttr;\nattributeSetters.readOnly = setBooleanAttr;\n\n// Class names muttator handle classes added only via template.\n// Any classes added via DOM manipulation will stay untouched and must be handled by user\nattributeSetters.className = attributeSetters['class'] = function(el, attr, value) {\n    value = value || '';\n\n    UtilsDOM.removeClass(el, el.__className);\n    UtilsDOM.addClass(el, value);\n    el.__className = value;\n};\n\nincrementalDOM.events = _.clone(Backbone.Events);\n\nfunction eventWrapper(event, args) {\n    var method = args[0];\n    var params = Array.prototype.slice.call(args, 1);\n    incrementalDOM.events.trigger.apply(incrementalDOM.events, [event + ':before'].concat(params));\n    var result = method.apply(null, params);\n    incrementalDOM.events.trigger.apply(incrementalDOM.events, [event + ':after'].concat(params));\n    return result;\n}\n\nincrementalDOM.elementOpen = _.wrap(incrementalDOM.elementOpen, function() {\n    return eventWrapper('elementOpen', arguments);\n});\nincrementalDOM.elementClose = _.wrap(incrementalDOM.elementClose, function() {\n    return eventWrapper('elementClose', arguments);\n});\nincrementalDOM.elementOpenStart = _.wrap(incrementalDOM.elementOpenStart, function() {\n    return eventWrapper('elementOpenStart', arguments);\n});\nincrementalDOM.elementOpenEnd = _.wrap(incrementalDOM.elementOpenEnd, function() {\n    return eventWrapper('elementOpenEnd', arguments);\n});\nincrementalDOM.elementVoid = function(tag) {\n    incrementalDOM.elementOpen.apply(null, arguments);\n    return incrementalDOM.elementClose(tag);\n};\n\n\nfunction patchWrapper(patch, node, renderFn, data) {\n    publish(Events.PATCH_START, node);\n    patch.call(null, node, renderFn, data);\n    publish(Events.PATCH_END, node);\n}\n\nincrementalDOM.patch = incrementalDOM.patchInner = _.wrap(incrementalDOM.patchInner, patchWrapper);\nincrementalDOM.patchOuter = _.wrap(incrementalDOM.patchOuter, patchWrapper);\n\nmodule.exports = incrementalDOM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/template/idom.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"Backbone\",\"commonjs2\":\"backbone\",\"commonjs\":\"backbone\",\"amd\":\"backbone\"}\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _ = require('underscore');\nvar Backbone = require('backbone');\nvar Dispatcher = _.clone(Backbone.Events);\n\n\nmodule.exports = {\n    publish: function() {\n        Dispatcher.trigger.apply(Dispatcher, arguments);\n    },\n    subscribe: function(channel, callback, context) {\n        Dispatcher.on(channel, callback, context);\n    },\n    unsubscribe: function(channel, callback, context) {\n        Dispatcher.off(channel, callback, context);\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/core/dispatcher.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nfunction hasClass(el, cname) {\n    return el.className ? el.className.match(new RegExp('(\\\\s|^)'+cname+'(\\\\s|$)')) : false;\n}\n\nfunction addClass(el, cnames) {\n    var classNames = cnames ? cnames.split(' ') : [];\n\n    classNames.forEach(function(cname){\n        if (!hasClass(el, cname)) {\n            el.className = el.className ? el.className + \" \" + cname : cname;\n        }\n    }, this);\n}\n\nfunction removeClass(el, cnames) {\n    var classNames = cnames ? cnames.split(' ') : [];\n\n    classNames.forEach(function(cname){\n        if (hasClass(el, cname)) {\n            el.className = el.className.replace(new RegExp('(\\\\s|^)'+cname+'(?=\\\\s|$)'),'');\n        }\n    }, this);\n}\n\nmodule.exports.hasClass = hasClass;\nmodule.exports.addClass = addClass;\nmodule.exports.removeClass = removeClass;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/DOM_Utils.js\n ** module id = 8\n ** module chunks = 0\n **/","var Config = {\n    // Specific RAD.js attributes to connect HTMLElement with its View\n    Attributes: {\n        ID: 'view-id',\n        ROLE: 'data-role'\n    },\n\n    // List of BaseView parameters which can be applied by passing as an options.\n    ViewOptions: ['key', 'propsModel', 'model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'],\n\n    // Internal Events used to communicate with modules\n    Events: {\n        REGISTER: 'register',\n        UNREGISTER: 'unregister',\n\n        ATTACH: 'attach',\n        DETACH: 'detach',\n\n        NODE_ATTACHED: 'nodeAdded',\n        NODE_REMOVED: 'nodeRemoved',\n\n        PATCH_START: 'patchStart',\n        PATCH_END:'patchEnd'\n    }\n};\n\nmodule.exports = Config;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/config/index.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar IncrementalDOM = require('incremental-dom');\nvar _ = require('underscore');\nvar iTemplate = require('idom-template');\nvar binder = require('./binder');\n\n/**\n *\n * Compile ejs string into IncrementalDOM annotation. iTemplate used for compiling.\n * @param {string} str - input EJS template string\n *\n * */\n\nfunction template(str) {\n    var templateFn = iTemplate.compile(str, null);\n\n    return function (data, content) {\n        return templateFn.call(this, data, IncrementalDOM, iTemplate.helpers, content, binder);\n    };\n}\n\nmodule.exports = template;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/template/index.js\n ** module id = 10\n ** module chunks = 0\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"itemplate\"] = factory();\n\telse\n\t\troot[\"itemplate\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _options = __webpack_require__(1);\n\tvar prepare = __webpack_require__(2);\n\tvar Parser = __webpack_require__(3);\n\tvar Builder = __webpack_require__(5);\n\n\tvar wrapper = __webpack_require__(6).createWrapper();\n\tvar builder = new Builder(wrapper);\n\tvar parser = new Parser(builder);\n\n\tvar helpers = {};\n\n\tvar itemplate = {\n\t    compile: function (string, library, scopedHelpers, rootKeys) {\n\t        builder.reset();\n\t        builder.set(\n\t            Object.keys(helpers),\n\t            scopedHelpers ? Object.keys(scopedHelpers) : [],\n\t            rootKeys\n\t        );\n\t        wrapper.set(library, helpers, null, string);\n\t        return parser.parseComplete(prepare(string));\n\t    },\n\t    options: function (options) {\n\t        // mix options\n\t        for (var key in options) {\n\t            if (options.hasOwnProperty(key))\n\t                _options[key] = options[key];\n\t        }\n\t    },\n\t    registerHelper: function (name, fn) {\n\t        helpers[name] = fn;\n\t    },\n\t    unregisterHelper: function (name) {\n\t        delete helpers[name];\n\t    }\n\t};\n\n\tObject.defineProperty(itemplate, 'helpers', {\n\t    get: function () {\n\t        return helpers;\n\t    },\n\t    set: function () {\n\t    }\n\t});\n\n\tmodule.exports = itemplate;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tvar _options = {\n\t    BREAK_LINE: /(\\r\\n|\\n|\\r)\\s{0,}/gm,\n\t    // prepare options\n\t    template: {\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\n\t        escape: /<%-([\\s\\S]+?)%>/g\n\t    },\n\t    order: ['interpolate', 'escape', 'evaluate'],\n\t    evaluate: {\n\t        name: 'script',\n\t        open: '<script>',\n\t        close: '</script>'\n\t    },\n\t    accessory: {\n\t        open: '{%',\n\t        close: '%}'\n\t    },\n\t    escape: /(&amp;|&lt;|&gt;|&quot;)/g,\n\t    MAP: {\n\t        '&amp;': '&',\n\t        '&lt;': '<',\n\t        '&gt;': '>',\n\t        '&quot;': '\"'\n\t    },\n\t    // build options\n\t    emptyString: true,\n\t    skipAttr: 'skip',\n\t    staticKey: 'key',\n\t    staticArray: 'static-array',\n\t    nonStaticAttributes: ['id', 'name', 'ref'],\n\t    binderPre: '::',\n\t    helperPre: 'i-',\n\t    parameterName: 'data',\n\t    parentParameterName: 'parent',\n\t    renderContentFnName: 'content',\n\t    // tags parse rules\n\t    textSaveTags: ['pre', 'code'],\n\t    voidRequireTags: ['input', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'keygen', 'link', 'meta',\n\t        'param', 'source', 'track', 'wbr'],\n\t    debug: false\n\t};\n\n\tmodule.exports = _options;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _options = __webpack_require__(1);\n\n\tfunction replacer(match, p1) {\n\t    return _options.accessory.open + p1 + _options.accessory.close;\n\t}\n\n\tvar methods = {\n\t    evaluate: function (string) {\n\t        return string.replace(_options.template.evaluate, function (match, p1) {\n\t            return _options.evaluate.open + p1.replace(_options.BREAK_LINE, ' ').trim() + _options.evaluate.close;\n\t        });\n\t    },\n\t    interpolate: function (string) {\n\t        return string.replace(_options.template.interpolate, replacer);\n\t    },\n\t    escape: function (string) {\n\t        return string.replace(_options.template.escape, replacer);\n\t    }\n\t};\n\n\tfunction prepare(string) {\n\t    var result = string;\n\t    for (var i = 0; i < _options.order.length; i++) {\n\t        result = methods[_options.order[i]](result);\n\t    }\n\t    return result;\n\t}\n\n\tmodule.exports = prepare;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mode = __webpack_require__(4);\n\n\tfunction Parser(builder) {\n\t    this._builder = builder;\n\t    this.reset();\n\t}\n\n\t//**Public**//\n\tParser.prototype.reset = function () {\n\t    this._state = {\n\t        mode: Mode.Text,\n\t        pos: 0,\n\t        data: null,\n\t        pendingText: null,\n\t        pendingWrite: null,\n\t        lastTag: null,\n\t        isScript: false,\n\t        needData: false,\n\t        output: [],\n\t        done: false\n\t    };\n\t    this._builder.reset();\n\t};\n\n\tParser.prototype.parseChunk = function (chunk) {\n\t    this._state.needData = false;\n\t    this._state.data = (this._state.data !== null) ? this._state.data.substr(this.pos) + chunk : chunk;\n\t    while (this._state.pos < this._state.data.length && !this._state.needData) {\n\t        this._parse(this._state);\n\t    }\n\t};\n\n\tParser.prototype.parseComplete = function (data) {\n\t    this.reset();\n\t    this.parseChunk(data);\n\t    return this.done();\n\t};\n\n\tParser.prototype.done = function () {\n\t    this._state.done = true;\n\t    this._parse(this._state);\n\t    this._flushWrite();\n\t    return this._builder.done();\n\t};\n\n\t//**Private**//\n\tParser.prototype._parse = function () {\n\t    switch (this._state.mode) {\n\t        case Mode.Text:\n\t            return this._parseText(this._state);\n\t        case Mode.Tag:\n\t            return this._parseTag(this._state);\n\t        case Mode.Attr:\n\t            return this._parseAttr(this._state);\n\t        case Mode.CData:\n\t            return this._parseCData(this._state);\n\t        case Mode.Doctype:\n\t            return this._parseDoctype(this._state);\n\t        case Mode.Comment:\n\t            return this._parseComment(this._state);\n\t    }\n\t};\n\n\tParser.prototype._writePending = function (node) {\n\t    if (!this._state.pendingWrite) {\n\t        this._state.pendingWrite = [];\n\t    }\n\t    this._state.pendingWrite.push(node);\n\t};\n\n\tParser.prototype._flushWrite = function () {\n\t    if (this._state.pendingWrite) {\n\t        for (var i = 0, len = this._state.pendingWrite.length; i < len; i++) {\n\t            var node = this._state.pendingWrite[i];\n\t            this._builder.write(node);\n\t        }\n\t        this._state.pendingWrite = null;\n\t    }\n\t};\n\n\tParser.prototype._write = function (node) {\n\t    this._flushWrite();\n\t    this._builder.write(node);\n\t};\n\n\tParser._re_parseText_scriptClose = /<\\s*\\/\\s*script/ig;\n\tParser.prototype._parseText = function () {\n\t    var state = this._state;\n\t    var foundPos;\n\t    if (state.isScript) {\n\t        Parser._re_parseText_scriptClose.lastIndex = state.pos;\n\t        foundPos = Parser._re_parseText_scriptClose.exec(state.data);\n\t        foundPos = (foundPos) ? foundPos.index : -1;\n\t    } else {\n\t        foundPos = state.data.indexOf('<', state.pos);\n\t    }\n\t    var text = (foundPos === -1) ? state.data.substring(state.pos, state.data.length) : state.data.substring(state.pos, foundPos);\n\t    if (foundPos < 0 && state.done) {\n\t        foundPos = state.data.length;\n\t    }\n\t    if (foundPos < 0) {\n\t        if (state.isScript) {\n\t            state.needData = true;\n\t            return;\n\t        }\n\t        if (!state.pendingText) {\n\t            state.pendingText = [];\n\t        }\n\t        state.pendingText.push(state.data.substring(state.pos, state.data.length));\n\t        state.pos = state.data.length;\n\t    } else {\n\t        if (state.pendingText) {\n\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t            text = state.pendingText.join('');\n\t            state.pendingText = null;\n\t        } else {\n\t            text = state.data.substring(state.pos, foundPos);\n\t        }\n\t        if (text !== '') {\n\t            this._write({type: Mode.Text, data: text});\n\t        }\n\t        state.pos = foundPos + 1;\n\t        state.mode = Mode.Tag;\n\t    }\n\t};\n\n\tParser.re_parseTag = /\\s*(\\/?)\\s*([^\\s>\\/]+)(\\s*)\\??(>?)/g;\n\tParser.prototype._parseTag = function () {\n\t    var state = this._state;\n\t    Parser.re_parseTag.lastIndex = state.pos;\n\t    var match = Parser.re_parseTag.exec(state.data);\n\n\t    if (match) {\n\t        if (!match[1] && match[2].substr(0, 3) === '!--') {\n\t            state.mode = Mode.Comment;\n\t            state.pos += 3;\n\t            return;\n\t        }\n\t        if (!match[1] && match[2].substr(0, 8) === '![CDATA[') {\n\t            state.mode = Mode.CData;\n\t            state.pos += 8;\n\t            return;\n\t        }\n\t        if (!match[1] && match[2].substr(0, 8) === '!DOCTYPE') {\n\t            state.mode = Mode.Doctype;\n\t            state.pos += 8;\n\t            return;\n\t        }\n\t        if (!state.done && (state.pos + match[0].length) === state.data.length) {\n\t            //We're at the and of the data, might be incomplete\n\t            state.needData = true;\n\t            return;\n\t        }\n\t        var raw;\n\t        if (match[4] === '>') {\n\t            state.mode = Mode.Text;\n\t            raw = match[0].substr(0, match[0].length - 1);\n\t        } else {\n\t            state.mode = Mode.Attr;\n\t            raw = match[0];\n\t        }\n\t        state.pos += match[0].length;\n\t        var tag = {type: Mode.Tag, name: match[1] + match[2], raw: raw, position: Parser.re_parseTag.lastIndex };\n\t        if (state.mode === Mode.Attr) {\n\t            state.lastTag = tag;\n\t        }\n\t        if (tag.name.toLowerCase() === 'script') {\n\t            state.isScript = true;\n\t        } else if (tag.name.toLowerCase() === '/script') {\n\t            state.isScript = false;\n\t        }\n\t        if (state.mode === Mode.Attr) {\n\t            this._writePending(tag);\n\t        } else {\n\t            this._write(tag);\n\t        }\n\t    } else {\n\t        state.needData = true;\n\t    }\n\t};\n\n\tParser.re_parseAttr_findName = /\\s*([^=<>\\s'\"\\/]+)\\s*/g;\n\tParser.prototype._parseAttr_findName = function () {\n\t    // todo: parse {{ checked ? 'checked' : '' }} in input\n\t    Parser.re_parseAttr_findName.lastIndex = this._state.pos;\n\t    var match = Parser.re_parseAttr_findName.exec(this._state.data);\n\t    if (!match) {\n\t        return null;\n\t    }\n\t    if (this._state.pos + match[0].length !== Parser.re_parseAttr_findName.lastIndex) {\n\t        return null;\n\t    }\n\t    return {\n\t        match: match[0],\n\t        name: match[1]\n\t    };\n\t};\n\tParser.re_parseAttr_findValue = /\\s*=\\s*(?:'([^']*)'|\"([^\"]*)\"|([^'\"\\s\\/>]+))\\s*/g;\n\tParser.re_parseAttr_findValue_last = /\\s*=\\s*['\"]?(.*)$/g;\n\tParser.prototype._parseAttr_findValue = function () {\n\t    var state = this._state;\n\t    Parser.re_parseAttr_findValue.lastIndex = state.pos;\n\t    var match = Parser.re_parseAttr_findValue.exec(state.data);\n\t    if (!match) {\n\t        if (!state.done) {\n\t            return null;\n\t        }\n\t        Parser.re_parseAttr_findValue_last.lastIndex = state.pos;\n\t        match = Parser.re_parseAttr_findValue_last.exec(state.data);\n\t        if (!match) {\n\t            return null;\n\t        }\n\t        return {\n\t            match: match[0],\n\t            value: (match[1] !== '') ? match[1] : null\n\t        };\n\t    }\n\t    if (state.pos + match[0].length !== Parser.re_parseAttr_findValue.lastIndex) {\n\t        return null;\n\t    }\n\t    return {\n\t        match: match[0],\n\t        value: match[1] || match[2] || match[3]\n\t    };\n\t};\n\tParser.re_parseAttr_splitValue = /\\s*=\\s*['\"]?/g;\n\tParser.re_parseAttr_selfClose = /(\\s*\\/\\s*)(>?)/g;\n\tParser.prototype._parseAttr = function () {\n\t    var state = this._state;\n\t    var name_data = this._parseAttr_findName(state);\n\t    if (!name_data || name_data.name === '?') {\n\t        Parser.re_parseAttr_selfClose.lastIndex = state.pos;\n\t        var matchTrailingSlash = Parser.re_parseAttr_selfClose.exec(state.data);\n\t        if (matchTrailingSlash && matchTrailingSlash.index === state.pos) {\n\t            if (!state.done && !matchTrailingSlash[2] && state.pos + matchTrailingSlash[0].length === state.data.length) {\n\t                state.needData = true;\n\t                return;\n\t            }\n\t            state.lastTag.raw += matchTrailingSlash[1];\n\t            this._write({type: Mode.Tag, name: '/' + state.lastTag.name, raw: null});\n\t            state.pos += matchTrailingSlash[1].length;\n\t        }\n\t        var foundPos = state.data.indexOf('>', state.pos);\n\t        if (foundPos < 0) {\n\t            if (state.done) {\n\t                state.lastTag.raw += state.data.substr(state.pos);\n\t                state.pos = state.data.length;\n\t                return;\n\t            }\n\t            state.needData = true;\n\t        } else {\n\t            // state.lastTag = null;\n\t            state.pos = foundPos + 1;\n\t            state.mode = Mode.Text;\n\t        }\n\t        return;\n\t    }\n\t    if (!state.done && state.pos + name_data.match.length === state.data.length) {\n\t        state.needData = true;\n\t        return null;\n\t    }\n\t    state.pos += name_data.match.length;\n\t    var value_data = this._parseAttr_findValue(state);\n\t    if (value_data) {\n\t        if (!state.done && state.pos + value_data.match.length === state.data.length) {\n\t            state.needData = true;\n\t            state.pos -= name_data.match.length;\n\t            return;\n\t        }\n\t        state.pos += value_data.match.length;\n\t    } else {\n\t        if (state.data.indexOf(' ', state.pos - 1)) {\n\t            value_data = {\n\t                match: '',\n\t                value: null\n\t            };\n\n\t        } else {\n\t            Parser.re_parseAttr_splitValue.lastIndex = state.pos;\n\t            if (Parser.re_parseAttr_splitValue.exec(state.data)) {\n\t                state.needData = true;\n\t                state.pos -= name_data.match.length;\n\t                return;\n\t            }\n\t            value_data = {\n\t                match: '',\n\t                value: null\n\t            };\n\t        }\n\t    }\n\t    state.lastTag.raw += name_data.match + value_data.match;\n\n\t    this._writePending({type: Mode.Attr, name: name_data.name, data: value_data.value});\n\t};\n\n\tParser.re_parseCData_findEnding = /\\]{1,2}$/;\n\tParser.prototype._parseCData = function () {\n\t    var state = this._state;\n\t    var foundPos = state.data.indexOf(']]>', state.pos);\n\t    if (foundPos < 0 && state.done) {\n\t        foundPos = state.data.length;\n\t    }\n\t    if (foundPos < 0) {\n\t        Parser.re_parseCData_findEnding.lastIndex = state.pos;\n\t        var matchPartialCDataEnd = Parser.re_parseCData_findEnding.exec(state.data);\n\t        if (matchPartialCDataEnd) {\n\t            state.needData = true;\n\t            return;\n\t        }\n\t        if (!state.pendingText) {\n\t            state.pendingText = [];\n\t        }\n\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t        state.pos = state.data.length;\n\t        state.needData = true;\n\t    } else {\n\t        var text;\n\t        if (state.pendingText) {\n\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t            text = state.pendingText.join('');\n\t            state.pendingText = null;\n\t        } else {\n\t            text = state.data.substring(state.pos, foundPos);\n\t        }\n\t        this._write({type: Mode.CData, data: text});\n\t        state.mode = Mode.Text;\n\t        state.pos = foundPos + 3;\n\t    }\n\t};\n\n\tParser.prototype._parseDoctype = function () {\n\t    var state = this._state;\n\t    var foundPos = state.data.indexOf('>', state.pos);\n\t    if (foundPos < 0 && state.done) {\n\t        foundPos = state.data.length;\n\t    }\n\t    if (foundPos < 0) {\n\t        Parser.re_parseCData_findEnding.lastIndex = state.pos;\n\t        if (!state.pendingText) {\n\t            state.pendingText = [];\n\t        }\n\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t        state.pos = state.data.length;\n\t        state.needData = true;\n\t    } else {\n\t        var text;\n\t        if (state.pendingText) {\n\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t            text = state.pendingText.join('');\n\t            state.pendingText = null;\n\t        } else {\n\t            text = state.data.substring(state.pos, foundPos);\n\t        }\n\t        this._write({type: Mode.Doctype, data: text});\n\t        state.mode = Mode.Text;\n\t        state.pos = foundPos + 1;\n\t    }\n\t};\n\n\tParser.re_parseComment_findEnding = /\\-{1,2}$/;\n\tParser.prototype._parseComment = function () {\n\t    var state = this._state;\n\t    var foundPos = state.data.indexOf('-->', state.pos);\n\t    if (foundPos < 0 && state.done) {\n\t        foundPos = state.data.length;\n\t    }\n\t    if (foundPos < 0) {\n\t        Parser.re_parseComment_findEnding.lastIndex = state.pos;\n\t        var matchPartialCommentEnd = Parser.re_parseComment_findEnding.exec(state.data);\n\t        if (matchPartialCommentEnd) {\n\t            state.needData = true;\n\t            return;\n\t        }\n\t        if (!state.pendingText) {\n\t            state.pendingText = [];\n\t        }\n\t        state.pendingText.push(state.data.substr(state.pos, state.data.length));\n\t        state.pos = state.data.length;\n\t        state.needData = true;\n\t    } else {\n\t        var text;\n\t        if (state.pendingText) {\n\t            state.pendingText.push(state.data.substring(state.pos, foundPos));\n\t            text = state.pendingText.join('');\n\t            state.pendingText = null;\n\t        } else {\n\t            text = state.data.substring(state.pos, foundPos);\n\t        }\n\n\t        this._write({type: Mode.Comment, data: text});\n\t        state.mode = Mode.Text;\n\t        state.pos = foundPos + 3;\n\t    }\n\t};\n\n\tmodule.exports = Parser;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar Mode = {\n\t    Text: 'text',\n\t    Tag: 'tag',\n\t    Attr: 'attr',\n\t    CData: 'cdata',\n\t    Doctype: 'doctype',\n\t    Comment: 'comment'\n\t};\n\n\tmodule.exports = Mode;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* private */\n\tvar _options = __webpack_require__(1);\n\tvar Mode = __webpack_require__(4);\n\tvar Command = __webpack_require__(6).Command;\n\n\tvar state; // current builder state\n\tvar stack; // result builder\n\tvar staticArraysHolder = {}; // holder for static arrays\n\tvar wrapper; // external wrapper functionality\n\tvar helpers; // keys for helpers\n\tvar localComponentNames = []; // keys for local helpers\n\n\tvar empty = '', quote = '\"', comma = ', \"', removable = '-%%&&##__II-'; // auxiliary\n\n\tvar nestingLevelInfo = {level: 0, skip: []};\n\n\tfunction isRootNode() {\n\t    return nestingLevelInfo.level === 0;\n\t}\n\n\tfunction makeKey() {\n\t    var text = new Array(12), possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefgijklmnopqrstuvwxyz';\n\t    for (var i = 0; i < 12; i++)\n\t        text.push(possible.charAt(Math.floor(Math.random() * possible.length)));\n\n\t    return text.join(empty);\n\t}\n\n\tfunction decodeAccessory(string, force) {\n\t    var regex = new RegExp(_options.accessory.open + '|' + _options.accessory.close, 'g');\n\t    var code;\n\t    var isStatic = true, openStub, closeStub;\n\n\t    if (string !== undefined)\n\t        code = string.split(regex).map(function (piece, i) {\n\t            openStub = '';\n\t            closeStub = '';\n\n\t            if (i % 2) {\n\t                isStatic = false;\n\t                piece = piece.trim();\n\t                if (_options.emptyString && !force) { // undefined as empty string\n\t                    if (piece.indexOf(' ') !== -1) {\n\t                        openStub = '(';\n\t                        closeStub = ')';\n\t                    }\n\t                    return ' + (' + openStub + piece + closeStub + ' === undefined ? \"\" : '\n\t                        + openStub + piece + closeStub + ') + ';\n\t                } else\n\t                    return ' + ' + piece + ' + ';\n\t            } else {\n\t                return JSON.stringify(piece);\n\t            }\n\t        }).join('');\n\t    else\n\t        code = '\"\"';\n\n\t    // micro-optimizations (remove appending empty strings)\n\t    code = code.replace(/^\"\" \\+ | \\+ \"\"$/g, '').replace(/ \\+ \"\" \\+ /g, ' + ');\n\n\t    return {value: code, isStatic: isStatic};\n\t}\n\n\tfunction formatText(text) {\n\t    return text.trim()\n\t        .replace(/&#(\\d+);/g, function (match, dec) {\n\t            return String.fromCharCode(dec);\n\t        })\n\t        .replace(_options.escape, function (m) {\n\t            return _options.MAP[m];\n\t        });\n\t}\n\n\tfunction prepareKey(command, attributes, useKeyCommand) {\n\t    var result = empty, decode, stub;\n\t    if ((command === Command.elementOpen || command === Command.elementVoid)) {\n\n\t        if (attributes && attributes.hasOwnProperty(_options.staticKey)) {\n\t            decode = decodeAccessory(attributes[_options.staticKey] || makeKey());\n\t            delete attributes[_options.staticKey];\n\t        } else if (useKeyCommand) {\n\t            decode = {value: Command.getKey};\n\t        } else {\n\t            decode = {value: 'null'};\n\t        }\n\t        stub = (Object.keys(attributes).length > 0) ? ', ' : empty;\n\t        result = ', ' + decode.value + stub;\n\t    }\n\t    return result;\n\t}\n\n\tfunction prepareAttr(command, attributes) {\n\t    var result = empty, attr, decode, arrayStaticKey = false, isSkipped = false, skipCommand;\n\t    if ((command === Command.elementOpen || command === Command.elementVoid) && Object.keys(attributes).length > 0) {\n\t        if (attributes && attributes.hasOwnProperty(_options.staticArray)) {\n\t            arrayStaticKey = attributes[_options.staticArray] || makeKey();\n\t            staticArraysHolder[arrayStaticKey] = staticArraysHolder[arrayStaticKey] || {};\n\t            delete attributes[_options.staticArray];\n\t        }\n\n\t        if (attributes && attributes.hasOwnProperty(_options.skipAttr)) {\n\t            isSkipped = true;\n\t            skipCommand = Command.startSkipContent(decodeAccessory(attributes[_options.skipAttr], true).value);\n\t            delete attributes[_options.skipAttr];\n\t        }\n\n\t        result = arrayStaticKey || null;\n\t        for (var key in attributes) {\n\t            attr = attributes[key];\n\t            attr = (attr === null) ? key : ((attr === undefined) ? '' : attr);\n\t            decode = decodeAccessory(attr);\n\t            if (decode.isStatic && (_options.nonStaticAttributes.indexOf(key) === -1)) {\n\t                if (arrayStaticKey) {\n\t                    var value = formatText(attr);\n\t                    if (!staticArraysHolder[arrayStaticKey].hasOwnProperty(key)) {\n\t                        staticArraysHolder[arrayStaticKey][key] = value;\n\t                    } else if (staticArraysHolder[arrayStaticKey][key] !== value) {\n\t                        staticArraysHolder[arrayStaticKey][key] = removable;\n\t                        result += comma + key + '\", \"' + value + quote;\n\t                    }\n\t                } else\n\t                    result += comma + key + '\", \"' + formatText(attr) + quote;\n\t            } else {\n\t                result += comma + key + '\", ' + formatText(decode.value);\n\t            }\n\t        }\n\t    }\n\t    return {value: result, isSkipped: isSkipped, skip: skipCommand};\n\t}\n\n\tfunction unwrapStaticArrays(holder) {\n\t    var result = {}, obj, key;\n\t    for (var arrayName in holder) {\n\t        obj = holder[arrayName];\n\t        result[arrayName] = [];\n\n\t        for (key in obj)\n\t            if (obj[key] !== removable)\n\t                result[arrayName].push(quote + key + quote, quote + obj[key] + quote);\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction decodeAttrs(obj) {\n\t    var result = ['{'];\n\t    for (var key in obj)\n\t        result.push(((result.length > 1) ? ',' : empty) + '\\'' + key + '\\'' + ':' + decodeAccessory(obj[key], true).value);\n\t    result.push('}');\n\n\t    return result.join(empty);\n\t}\n\n\tfunction camelCase(input) {\n\t    return input.replace(/\\s/g, '').replace(/-(.)/g, function (match, group1) {\n\t        return group1.toUpperCase();\n\t    });\n\t}\n\n\tfunction writeCommand(command, tag, attributes) {\n\t    if (attributes && attributes.ref) {\n\t        var refName = attributes.ref;\n\t        delete attributes.ref;\n\t    }\n\n\t    var strKey = prepareKey(command, attributes);\n\t    var strAttrs = prepareAttr(command, attributes);\n\n\t    if (refName) {\n\t        // i.e. ref[refName] = elementOpen(...)\n\t        command = Command.saveRef(camelCase(decodeAccessory(refName, true).value), command);\n\t    }\n\n\t    stack.push(command + tag + quote + strKey + strAttrs.value + Command.close);\n\n\t    // save skipped\n\t    if (strAttrs.isSkipped) {\n\t        stack.push(strAttrs.skip);\n\t        nestingLevelInfo.skip.push(nestingLevelInfo.level);\n\t    }\n\t}\n\n\tfunction writeText(text) {\n\t    text = formatText(text);\n\t    if (text.length > 0) {\n\t        var decode = decodeAccessory(text);\n\t        stack.push(Command.text + decode.value + Command.close);\n\t    }\n\t}\n\n\tfunction helperOpen(helperName, attrs) {\n\t    stack.push(Command.helpers + '[\"' + helperName + '\"](' + decodeAttrs(attrs) + ', function (' \n\t        + _options.parentParameterName + '){');\n\t}\n\n\tfunction helperClose() {\n\t    stack.push('}.bind(this));');\n\t}\n\n\tfunction isHelperTag(tagName) {\n\t    return localComponentNames.indexOf(tagName) !== -1 \n\t        || helpers.indexOf(tagName) !== -1\n\t        || tagName.indexOf(_options.helperPre) === 0;\n\t}\n\n\tfunction binderOpen(helperName, attrs) {\n\t    var fnName = helperName.replace(_options.binderPre, '');\n\t    stack.push(Command.binder + '(' + fnName + ',' + decodeAttrs(attrs) + ', function (' \n\t        + _options.parentParameterName + '){');\n\t}\n\n\tfunction binderClose() {\n\t    stack.push('}.bind(this));');\n\t}\n\n\tfunction isTagBinded(tagName) {\n\t    return tagName.indexOf(_options.binderPre) === 0;\n\t}\n\n\t// TODO: Clarify logic.\n\t// Seems like this method only opens state but named as 'CloseOpenState'\n\t// also seems like `isClosed` flags used only to detect elementVoid and it's a bit confusing\n\t// because sounds like it can be used to detect tags open or close state.\n\tfunction writeAndCloseOpenState(isClosed) {\n\t    var isShouldClose = true;\n\n\t    if (state.tag) {\n\t        var isRoot = isRootNode();\n\n\t        if (isHelperTag(state.tag)) { // helper case\n\t            helperOpen(state.tag, state.attributes);\n\t            isShouldClose = isClosed;\n\t        } else if (isTagBinded(state.tag)) {\n\t            binderOpen(state.tag, state.attributes);\n\t            isShouldClose = isClosed;\n\t        } else if (isClosed || _options.voidRequireTags.indexOf(state.tag) !== -1) { // void mode\n\t            writeCommand(Command.elementVoid, state.tag, state.attributes, isRoot);\n\t            nestingLevelInfo.level--;\n\t            isShouldClose = false;\n\t        } else if (state.tag !== _options.evaluate.name) { // standard mode\n\t            writeCommand(Command.elementOpen, state.tag, state.attributes, isRoot);\n\t        } // if we write code, do nothing\n\n\t        nestingLevelInfo.level++;\n\t    }\n\n\t    // clear builder state for next tag\n\t    state.tag = null;\n\t    state.attributes = {};\n\n\t    return isShouldClose; // should we close this tag: no if we have void element\n\t}\n\n\t/* public */\n\tfunction Builder(functionWrapper) {\n\t    wrapper = functionWrapper;\n\t    this.reset();\n\t}\n\n\tBuilder.prototype.reset = function () {\n\t    stack = [];\n\t    state = {\n\t        tag: null,\n\t        attributes: {}\n\t    };\n\t    staticArraysHolder = {};\n\t    nestingLevelInfo = {level: 0, skip: []};\n\t};\n\n\tBuilder.prototype.set = function (helpersKeys, localNames) {\n\t    helpers = helpersKeys;\n\t    localComponentNames = localNames || [];\n\t};\n\n\tBuilder.prototype.write = function (command) {\n\t    var tag;\n\t    switch (command.type) {\n\t        case Mode.Tag:\n\t            tag = command.name.replace('/', empty);\n\n\t            if (command.name.indexOf('/') === 0) {\n\n\t                // close tag case\n\t                if (writeAndCloseOpenState(true) && tag !== _options.evaluate.name) {\n\t                    nestingLevelInfo.level--;\n\n\t                    // write end skip functionality\n\t                    if (nestingLevelInfo.level === nestingLevelInfo.skip[nestingLevelInfo.skip.length - 1]) {\n\t                        stack.push(Command.endSkipContent);\n\t                        nestingLevelInfo.skip.pop();\n\t                    }\n\n\t                    if (isHelperTag(tag))\n\t                        helperClose();\n\t                    else if (isTagBinded(tag))\n\t                        binderClose();\n\t                    else\n\t                        writeCommand(Command.elementClose, tag);\n\t                }\n\t            } else {\n\t                // open tag case\n\t                writeAndCloseOpenState();\n\t                state.tag = tag;\n\t                state.attributes = {};\n\t            }\n\t            break;\n\t        case Mode.Attr: // push attribute in state\n\t            state.attributes[command.name] = command.data;\n\t            break;\n\t        case Mode.Text: // write text\n\t            tag = state.tag;\n\t            writeAndCloseOpenState();\n\t            if (tag === _options.evaluate.name) { // write code\n\t                stack.push(formatText(command.data));\n\t            } else {\n\t                writeText(command.data);\n\t            }\n\t            break;\n\t        case Mode.Comment: // write comments only in debug mode\n\t            if (_options.debug)\n\t                stack.push('\\n// ' + command.data.replace(_options.BREAK_LINE, ' ') + '\\n');\n\t            break;\n\t    }\n\t};\n\n\tBuilder.prototype.done = function () {\n\t    return wrapper(stack, unwrapStaticArrays(staticArraysHolder));\n\t};\n\n\tmodule.exports = Builder;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _options = __webpack_require__(1);\n\n\tvar Command = { // incremental DOM commands\n\t    helpers: '_h',\n\t    binder: '_b',\n\t    elementOpen: '_o(\"',\n\t    elementClose: '_c(\"',\n\t    elementVoid: '_v(\"',\n\t    saveRef: function (name, command) {\n\t        return '_r[' + name + '] = ' + command;\n\t    },\n\t    text: '_t(',\n\t    close: ');\\n',\n\t    startSkipContent: function (flag) {\n\t        // compile static values\n\t        flag = (flag === '\"false\"') ? false : flag;\n\t        flag = (flag === '\"true\"') ? true : flag;\n\n\t        return 'if(' + flag + '){_l.skip();}else{';\n\t    },\n\t    endSkipContent: '}'\n\t};\n\n\tfunction createWrapper() {\n\t    var _library, _helpers, _fnName, _template;\n\t    var glue = '';\n\t    var eol = '\\n';\n\n\t    function wrapFn(body) {\n\t        var returnValue = eol + ' return _r;';\n\n\t        var prepareError = 'var TE=function(m,n,o){this.original=o;this.name=n;(o)?this.stack=this.original.stack:' +\n\t            'this.stack=null;this.message=o.message+m;};var CE=function(){};CE.prototype=Error.prototype;' +\n\t            'TE.prototype=new CE();TE.prototype.constructor=TE;';\n\n\t        if (_options.debug) {\n\t            return 'try {'\n\t                + body +\n\t                '} catch (err) {'\n\t                + prepareError +\n\t                'throw new TE(' + JSON.stringify(_template) + ', err.name, err);' +\n\t                '}'\n\t                + returnValue;\n\t        }\n\t        return body + returnValue;\n\t    }\n\n\t    function wrapper(stack, holder) {\n\t        var resultFn;\n\t        var variables = [\n\t                'var _o = _l.elementOpen;',\n\t                'var _c = _l.elementClose;',\n\t                'var _v = _l.elementVoid;',\n\t                'var _t = _l.text;',\n\t                'var _r = {};',\n\t                '_b = _b || function(fn, data, content){ return fn(data, content); };'\n\t            ].join(eol) + eol;\n\n\t        for (var key in holder) { // collect static arrays for function\n\t            if (holder.hasOwnProperty(key))\n\t                variables += 'var ' + key + '=[' + holder[key] + '];';\n\t        }\n\t        var body = variables + wrapFn(stack.join(glue));\n\n\t        if (_library) {\n\t            body = 'return function(' + _options.parameterName + ', ' + _options.renderContentFnName + ', _b){' + body + '};';\n\t            resultFn = (new Function('_l', '_h', body))(_library, _helpers);\n\t        } else {\n\t            resultFn = new Function(_options.parameterName, '_l', '_h', _options.renderContentFnName, '_b', body);\n\t        }\n\t        return resultFn;\n\t    }\n\n\t    wrapper.set = function (library, helpers, fnName, template) {\n\t        _library = library;\n\t        _helpers = helpers;\n\t        _fnName = fnName;\n\t        _template = template;\n\t    };\n\n\t    return wrapper;\n\t}\n\n\tmodule.exports = {\n\t    createWrapper: createWrapper,\n\t    Command: Command\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/idom-template/bin/itemplate.js\n ** module id = 11\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _ = require(\"underscore\");\nvar core = require('../core/index');\nvar Config = require('../config/index');\n\nfunction binder(component, props, content) {\n\n    var BaseView = require('./../blanks/view');\n    \n    props = props || {};\n    props.key = props.key || props.id;\n\n    // If BaseView instance was passed\n    if (component instanceof BaseView) {\n        component.props.set(_.omit(props, Config.ViewOptions), {silent:true});\n        return component.render();\n    }\n\n    // If component with passed key already registered\n    var registrationId = 'view-key-' + props.key;\n    var registeredComponent = core.get( registrationId );\n\n    if (registeredComponent) {\n        registeredComponent.props.set(_.omit(props, Config.ViewOptions), {silent:true});\n        return registeredComponent.render();\n    }\n\n    // If new component was passed\n    var newComponent = _.isFunction(component) ? new component(props, content) : component;\n    if (newComponent instanceof BaseView) {\n        return newComponent.render();\n    }\n\n    return newComponent;\n}\n\nmodule.exports = binder;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/template/binder.js\n ** module id = 12\n ** module chunks = 0\n **/","\"use strict\";\nvar _ = require('underscore');\nvar Dispatcher = require('./dispatcher');\nvar InternalEvents = require('../config').Events;\n\nvar modules = {};\n\nvar defaults = {\n    debug: false,\n    parameterName: 'data',\n    viewAttributes: {\n        'data-role': 'view'\n    }\n};\n\nfunction Core(Dispatcher) {\n    this.options = defaults;\n\n    Dispatcher.subscribe(InternalEvents.REGISTER, this.register, this);\n    Dispatcher.subscribe(InternalEvents.UNREGISTER, this.unregister, this);\n}\n\n\n/**\n *  Override RAD.js default settings\n *\n *  @param {Object} options\n *  @param {string} [options.parameterName = model] - Sets the name of the argument to be passed to the template function.\n *  @param {boolean} [options.debug = false]        - Enable console logging\n */\nCore.prototype.setOptions = function(options) {\n    _.extend(this.options, options);\n};\n\nCore.prototype.get = function (id) {\n    return modules[id];\n};\n\nCore.prototype.getAll = function () {\n    return _.clone(modules);\n};\n\nCore.prototype.register = function (id, obj) {\n    if (modules[id]) {\n        throw new Error('Such module ID: '+id+' already registered');\n    }\n    modules[id] = obj;\n};\n\nCore.prototype.unregister = function (id) {\n    if (modules[id]) {\n        delete modules[id];\n    }\n};\n\n\nmodule.exports = new Core( Dispatcher );\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/core/index.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _ = require('underscore');\nvar Backbone = require('backbone');\n\nvar IncrementalDOM = require('../template/idom');\nvar Dispatcher = require('../core/dispatcher');\nvar Config = require('../config');\nvar Events = Config.Events;\nvar Core = require('../core');\nvar defaultAttributes = Core.options.viewAttributes;\nvar register = Core.register;\nvar unregister = Core.unregister;\n\nfunction isRendering() {\n    return !!IncrementalDOM.currentElement();\n}\n\nfunction makeId(options) {\n    if (options && options.key) {\n        return 'view-key-' + options.key;\n    }\n    return _.result(options, 'id', _.uniqueId('view-'));\n}\n\nfunction compileTemplate(template) {\n    return typeof template === 'string' ? RAD.template(template) : template;\n}\n\nfunction hasKey(node) {\n    return node.__incrementalDOMData && node.__incrementalDOMData.key;\n}\n\nvar BaseView = function(options) {\n    this.viewId = makeId(options);\n    this.refs = {};\n\n    var Props = this.propsModel || Backbone.Model;\n    this.props = new Props( _.omit(options, Config.ViewOptions) );\n\n    this._bindChannels();\n    Backbone.View.apply(this, arguments);\n    this.template = compileTemplate(this.template);\n    this.bindRender(this.props, 'change');\n\n    register(this.getID(), this);\n};\n\nBaseView.prototype = _.create(Backbone.View.prototype, {\n    _bindChannels: function() {\n        var id = this.getID();\n        var attachMsg = id + ':' + Events.ATTACH;\n        var detachMsg = id + ':' + Events.DETACH;\n\n        this.subscribe(id, this.onReceiveMsg, this);\n        this.subscribe(attachMsg, this.onAttach, this);\n        this.subscribe(detachMsg, this.onDetach, this);\n\n        if (isRendering()) {\n            this.subscribe(detachMsg, this.destroy, this);\n        }\n    },\n\n    setElement: function(el) {\n        var $el = el instanceof Backbone.$ ? el : Backbone.$(el);\n        var viewId = $el.attr(Config.Attributes.ID);\n\n        if (viewId && viewId !== this.getID()) {\n            throw new Error('You cannot setElement which is used by another View.');\n        } else {\n            Backbone.View.prototype.setElement.call(this, $el);\n        }\n    },\n\n    getID: function() {\n        return this.viewId;\n    },\n\n    getTemplateData: function() {\n        return {\n            collection: this.collection && this.collection.toJSON(),\n            model: this.model && this.model.toJSON(),\n            props: this.props.toJSON()\n        };\n    },\n\n    bindRender: function(target, events) {\n        this.listenTo(target, events, this.render);\n    },\n\n    render: function () {\n        if (isRendering()) {\n            this._render();\n        } else {\n            this._renderOuter();\n        }\n        return this;\n    },\n\n    _renderOuter: function() {\n        var self = this;\n        IncrementalDOM.patchOuter(this.el, function() {\n            if (hasKey(self.el)) {\n                self._render();\n            } else {\n                self.el.setAttribute('key', self.getID());\n                self._render();\n                self.el.removeAttribute('key');\n            }\n        });\n        return this;\n    },\n\n    _render: function () {\n        if (this.onBeforeRender() === false) {\n            return this._skip();\n        }\n\n        this._viewElOpen();\n        this._renderTemplate();\n        this._viewElClose();\n\n        this.onRender();\n        return this;\n    },\n\n    _renderTemplate: function() {\n        if (typeof this.template === 'function') {\n            this.refs = this.template(this.getTemplateData());\n        } else {\n            IncrementalDOM.skip();\n        }\n    },\n\n    _skip: function() {\n        this._viewElOpen();\n        IncrementalDOM.skip();\n        this._viewElClose();\n        return this;\n    },\n    _viewElOpen: function () {\n        IncrementalDOM.elementOpenStart(this.el.tagName.toLowerCase(), this.getID());\n        this._setElAttributes();\n        IncrementalDOM.elementOpenEnd();\n    },\n    _viewElClose: function () {\n        var el = IncrementalDOM.elementClose(this.el.tagName.toLowerCase());\n        if (this.el !== el) {\n            this.setElement(el);\n        }\n    },\n    _setElAttributes: function() {\n        var attributes = _.extend({}, defaultAttributes, _.result(this, 'attributes', {}));\n        attributes.id = _.result(this, 'id');\n        attributes.class = _.result(this, 'className');\n        attributes[Config.Attributes.ID] = this.getID();\n\n        _.each(attributes, function (value, name) {\n            IncrementalDOM.attr(name, value);\n        });\n    },\n\n    _removeElement: function () {\n        this.$el.remove();\n        this.publish(Events.NODE_REMOVED, this.el);\n        return this;\n    },\n\n    destroy: function () {\n        this.unsubscribe(null, null, this);\n        unregister(this.getID());\n\n        this.remove();\n        this.onDestroy();\n\n        this.off();\n        this.undelegateEvents();\n    },\n    subscribe: function(channel, callback, context) {\n        return Dispatcher.subscribe(channel, callback, context || this);\n    },\n    unsubscribe: function(channel, callback, context) {\n        return Dispatcher.unsubscribe(channel, callback, context || this);\n    },\n    publish: function() {\n        return Dispatcher.publish.apply(Dispatcher, arguments);\n    }\n});\n\n_.extend(BaseView.prototype, {\n    onReceiveMsg:   function () {},\n    onBeforeRender: function () {},\n    onRender:       function () {},\n    onAttach:       function () {},\n    onDetach:       function () {},\n    onDestroy:      function () {}\n});\n\nBaseView.extend = function(protoProps, staticProps) {\n    return Backbone.View.extend.apply(this, arguments)\n};\n\nmodule.exports = BaseView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/blanks/view.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar IDOM_DATA = '__incrementalDOMData';\nvar RENDER_DATA = '__renderData';\n\n\nfunction getNodeData(el) {\n    return el[IDOM_DATA];\n}\n\nfunction setRenderData(node, options) {\n    if (!node[RENDER_DATA]) {\n        node[RENDER_DATA] = {};\n    }\n    return _.extend(node[RENDER_DATA], options);\n}\n\nfunction getRenderData(node) {\n    return node[RENDER_DATA] || setRenderData(node, {});\n}\n\nfunction toArray(args, startIndex) {\n    return Array.prototype.slice.call(args, startIndex || 0);\n}\n\nmodule.exports = {\n    getNodeData: getNodeData,\n    getRenderData: getRenderData,\n    setRenderData: setRenderData,\n    toArray: toArray\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/utils.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('underscore');\nvar publish = require('../../core/dispatcher').publish;\nvar iDOM = require('../../template/idom');\nvar Events = require('../../config').Events;\nvar utils = require('./utils');\nvar transition = require('./transition');\nvar initTransitionOptions = require('./options');\n\nvar RenderStatus = {\n    ENTER: 'enter',\n    LEAVE: 'leave',\n    DONE: 'done'\n};\n\nvar isPlaceholder = false;\n\nfunction createPlaceholder(node) {\n    var key = utils.getNodeData(node).key;\n    var tagName = node.tagName.toLowerCase();\n    isPlaceholder = true;\n    iDOM.elementOpen.apply(null, [tagName, key, null].concat( utils.getNodeData(node).attrsArr ));\n    iDOM.skip();\n    iDOM.elementClose(tagName);\n    isPlaceholder = false;\n}\n\nfunction alignContent(children, position, key) {\n    var length = children.length;\n    var node = children[position];\n\n    while (position < length && node && utils.getNodeData(node).key !== key) {\n        createPlaceholder(node);\n        node = children[++position];\n    }\n\n    return position;\n}\n\nfunction renderStart(renderData) {\n    var position = renderData.position;\n    var children = renderData.children;\n    var keyMap = renderData.keyMap;\n    var level = 0;\n    var childLevel = 1;\n    var isNewChild = false;\n\n    function beforeCreate(tagName, key) {\n        if (isPlaceholder) {\n            return;\n        }\n\n        var isChild = (++level) === childLevel;\n        isNewChild = false;\n\n        if (isChild) {\n            // Check if opened Element is already present in the list.\n            if (keyMap[key]) {\n                // If so then align its position with current content and return new position\n                position = alignContent(children, position, key);\n            } else {\n                isNewChild = true;\n            }\n            position++;\n        }\n    }\n    function afterCreate(tagName, key) {\n        if (isPlaceholder) {\n            return;\n        }\n\n        var isChild = level === childLevel;\n        var node = iDOM.currentElement();\n\n        if (isChild) {\n            renderData.keysRendered[key] = node;\n        }\n        if (isNewChild) {\n            children.splice(position - 1, 0, node);\n            keyMap[key] = node;\n            renderData.keysToShow[key] = node;\n        }\n\n        renderData.position = position;\n    }\n\n    iDOM.events.on('elementOpen:before', beforeCreate, renderData);\n    iDOM.events.on('elementOpen:after', afterCreate, renderData);\n    iDOM.events.on('elementClose:after', function() {\n        if (!isPlaceholder) {\n            level--;\n        }\n    }, renderData);\n\n    var elementOpenKey;\n    iDOM.events.on('elementOpenStart:before', function(tagName, key) {\n        if (!isPlaceholder) {\n            elementOpenKey = key;\n            beforeCreate(tagName, key);\n        }\n    }, renderData);\n\n    iDOM.events.on('elementOpenEnd:after', function(tagName, key) {\n        if (!isPlaceholder) {\n            afterCreate(tagName, elementOpenKey);\n        }\n    }, renderData);\n}\n\nfunction renderStop(renderData) {\n    iDOM.events.off(null, null, renderData);\n\n    alignContent(renderData.children, renderData.position);\n}\n\nfunction doTransition(renderData, runner) {\n    var rootEl = renderData.rootEl;\n    var activeKeys = utils.getNodeData(rootEl).keyMap;\n    var transitionOptions = initTransitionOptions(renderData.attrs);\n    var children = Array.prototype.slice.call(rootEl.children);\n\n    if (!renderData.applyAnimation) {\n        transitionOptions.enterTimeout = transitionOptions.leaveTimeout = 0;\n    }\n\n    _.each(children, function(node) {\n        var key = utils.getNodeData(node).key;\n        var render = utils.getRenderData(node);\n\n        if (!renderData.keysRendered[key]) {\n            if (render.status !== RenderStatus.LEAVE) {\n                render.status = RenderStatus.LEAVE;\n                transition.leave(node, transitionOptions, function() {\n                    render.status = RenderStatus.DONE;\n                    delete activeKeys[key];\n                    publish(Events.NODE_REMOVED, node, runner);\n                }, runner);\n           }\n        } else if (renderData.keysToShow[key] || render.status === RenderStatus.LEAVE) {\n            if (render.status !== RenderStatus.ENTER) {\n            render.status = RenderStatus.ENTER;\n                transition.enter(node, transitionOptions, function () {\n                    render.status = RenderStatus.DONE;\n                }, runner);\n            }\n        }\n    });\n}\n\nmodule.exports = {\n    start: renderStart,\n    stop: renderStop,\n    doTransition: doTransition\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/contentHandler.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nvar AnimationEnd = require('../../utils/transition/animationEnd');\nvar TransitionEnd = require('../../utils/transition/transitionEnd');\nvar utilsDOM = require('../../utils/DOM_Utils');\nvar sep = ' ';\n\nfunction clearTransitionTimeout(node) {\n    if (node.__transitionId) {\n        clearTimeout(node.__transitionId);\n        node.__transitionId = null;\n    }\n}\n\nfunction setTransitionTimeout(node, cb, timeout) {\n    node.__transitionId = setTimeout(function () {\n        cb(node);\n    }, timeout);\n}\n\nfunction hasActiveTransition(node) {\n    return node.__transitionId && node.stopActiveTransition;\n}\n\nfunction transition(node, options, timeout, callback) {\n    var transitionEnd = new TransitionEnd(node);\n    var animationEnd = new AnimationEnd(node);\n    var triggers = [\n        options.animationEnter,\n        options.animationLeave,\n        options.enterClass,\n        options.leaveClass,\n        options.activeClass\n    ].join(sep);\n\n    node.stopActiveTransition = function () {\n        clearTransitionTimeout(node);\n        transitionEnd.unbindAll();\n        animationEnd.unbindAll();\n        utilsDOM.removeClass(node, triggers);\n    };\n\n    function done() {\n        node.stopActiveTransition();\n        callback && callback(node);\n    }\n\n    function onTransitionEnd(e) {\n        if (e.target === node) {\n            done();\n        }\n    }\n\n    // handle both animation and transition\n    transitionEnd.bind(onTransitionEnd);\n    animationEnd.bind(onTransitionEnd);\n\n    if (!timeout) {\n        return done();\n    }\n\n    setTransitionTimeout(node, done, timeout);\n\n    // Run transition\n    utilsDOM.addClass(node, options.activeClass);\n}\n\nfunction transitionLeave(node, options, callback, runner) {\n    if (hasActiveTransition(node)) {\n        node.stopActiveTransition();\n    }\n\n    utilsDOM.addClass(node, [options.leaveClass].join(sep));\n    utilsDOM.removeClass(node, options.enterClass);\n\n    runner.push(function () {\n        utilsDOM.addClass(node, [options.animationLeave].join(sep));\n        transition(node, options, options.leaveTimeout, function (node) {\n            node.parentNode && node.parentNode.removeChild(node);\n            callback && callback();\n        });\n    });\n}\n\nfunction transitionEnter(node, options, callback, runner) {\n    if (hasActiveTransition(node)) {\n        node.stopActiveTransition();\n    }\n\n    utilsDOM.addClass(node, [options.enterClass].join(sep));\n    utilsDOM.removeClass(node, options.leaveClass);\n\n    runner.push(function () {\n        utilsDOM.addClass(node, [options.animationEnter].join(sep));\n        transition(node, options, options.enterTimeout, callback);\n    });\n}\n\nmodule.exports.enter = transitionEnter;\nmodule.exports.leave = transitionLeave;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/transition.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nvar TransitionEnd = require('./transitionEnd');\nvar whichCssEvent = require('./whichCssEvent');\nvar ANIMATION_DATA = '__animationData';\n\nfunction AnimationEnd(el) {\n    TransitionEnd.call(this, el);\n}\n\nAnimationEnd.prototype = Object.create(TransitionEnd.prototype);\nAnimationEnd.prototype.constructor = AnimationEnd;\n\nAnimationEnd.prototype._initData = function() {\n    this.el[ANIMATION_DATA] = {\n        eventName: whichCssEvent({\n            \"animation\"      : \"animationend\",\n            \"MozAnimation\"   : \"animationend\",\n            \"WebkitAnimation\": \"webkitAnimationEnd\"\n        }),\n        callbacks: []\n    };\n};\n\nAnimationEnd.prototype._getData = function() {\n    return this.el[ANIMATION_DATA];\n};\n\nmodule.exports = AnimationEnd;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/transition/animationEnd.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\nvar whichCssEvent = require('./whichCssEvent');\nvar TRANSITION_DATA = '__transitionData';\n\nfunction TransitionEnd(el) {\n    this.el = el && (el[0] || el);\n\n    if (!(this.el instanceof HTMLElement)) {\n        throw new Error('HTMLElement must be passed as an argument');\n    }\n\n    if (!this._getData()) {\n        this._initData();\n    }\n}\n\nTransitionEnd.prototype._initData = function() {\n    this.el[TRANSITION_DATA] = {\n        eventName: whichCssEvent({\n            'transition'      :'transitionend',\n            'MozTransition'   :'transitionend',\n            'WebkitTransition':'webkitTransitionEnd'\n        }),\n        callbacks: []\n    };\n};\n\nTransitionEnd.prototype._getData = function() {\n    return this.el[TRANSITION_DATA];\n};\n\nTransitionEnd.prototype.bind = function(fn) {\n    var data = this._getData();\n\n    if (data.callbacks.indexOf(fn) === -1) {\n        data.callbacks.push(fn);\n        this.el.addEventListener(data.eventName, fn, false);\n    }\n};\n\nTransitionEnd.prototype.unbind = function(fn) {\n    var data = this._getData(),\n        index = data.callbacks.indexOf(fn);\n\n    if (index !== -1) {\n        data.callbacks.splice(index, 1);\n        this.el.removeEventListener(data.eventName, fn, false);\n    }\n};\n\nTransitionEnd.prototype.unbindAll = function() {\n    this._getData().callbacks.forEach(this.unbind, this);\n};\n\n\nmodule.exports = TransitionEnd;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/transition/transitionEnd.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function whichCssEvents(eventsMap) {\n    var name,\n        testEl = document.createElement(\"xelement\");\n\n    for (name in eventsMap){\n        if (testEl.style[name] !== undefined) {\n            return eventsMap[name];\n        }\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/transition/whichCssEvent.js\n ** module id = 20\n ** module chunks = 0\n **/","'use strict';\n\nvar DEFAULT_LEAVE_CLASS = 'leave';\nvar DEFAULT_ENTER_CLASS = 'enter';\nvar DEFAULT_ACTIVE_CLASS = 'animated';\nvar DEFAULT_TIMEOUT = 3500;\n\n\nmodule.exports = function (attrs) {\n    var enterTimeout = parseInt(attrs.enterTimeout, 10);\n    var leaveTimeout = parseInt(attrs.leaveTimeout, 10);\n    var animationName = attrs.name || attrs.animationName;\n\n    return {\n        animationEnter: attrs.animationEnter || animationName,\n        animationLeave: attrs.animationLeave || animationName,\n        initialAnimation: attrs.initialAnimation,\n\n        enterClass: attrs.enterClass || DEFAULT_ENTER_CLASS,\n        leaveClass: attrs.leaveClass || DEFAULT_LEAVE_CLASS,\n\n        enterTimeout: isNaN(enterTimeout) ? DEFAULT_TIMEOUT : enterTimeout,\n        leaveTimeout: isNaN(leaveTimeout) ? DEFAULT_TIMEOUT : leaveTimeout,\n\n        activeClass: attrs.activeClass || DEFAULT_ACTIVE_CLASS\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/options.js\n ** module id = 21\n ** module chunks = 0\n **/","function Runner(name) {\n    this.name = name;\n    this.callbacks = [];\n}\n\nRunner.prototype.push = function (callback) {\n    this.callbacks.push(callback);\n};\n\nRunner.prototype.execute = function () {\n    for (var i = this.callbacks.length - 1; i >= 0; i--)\n        this.callbacks.pop()();\n};\n\nvar query = {\n\n    runners: {},\n\n    create: function (options) {\n        var delay;\n\n        // extract delay value\n        if (options && options.hasOwnProperty('delay')) {\n            delay = parseInt(options.delay, 10) || 0;\n        }\n\n        // generate name for runner\n        var name = \"name_\" + Math.random().toString(16).slice(2);\n        if (options && options.hasOwnProperty('groupName')) {\n            name = options.groupName;\n        }\n\n        // push runner to query\n        if (!this.runners.hasOwnProperty(name)) {\n            this.runners[name] = [];\n        }\n\n        var runner = new Runner(name);\n        this.runners[name].push(runner);\n        this.runners[name].delay = delay;\n\n        return runner;\n    },\n\n    run: function (name) {\n        var runners = this.runners[name];\n        if (runners) {\n            var delay = this.runners[name].delay;\n\n            function execute() {\n                for (var i = runners.length - 1; i >= 0; i--) {\n                    runners.pop().execute();\n                }\n            }\n\n            if (delay !== undefined) {\n                setTimeout(execute, delay);\n            } else {\n                execute();\n            }\n            this.runners[name] = [];\n        }\n    }\n};\n\nmodule.exports = query;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/transition_group/runner.js\n ** module id = 22\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _ = require('underscore');\n\nvar Module = require('../../blanks/module');\nvar Events = require('../../config').Events;\nvar Attrs = require('../../config').Attributes;\n\nvar LayoutManager = Module.extend({\n    activePatches: [],\n\n    initialize: function() {\n        this.subscribe(Events.PATCH_START, this.onPatchStart, this);\n        this.subscribe(Events.PATCH_END, this.onPatchEnd, this);\n        this.subscribe(Events.NODE_REMOVED, this.onNodeRemove, this);\n    },\n\n    onNodeRemove: function(node) {\n        var ids = this.getChildIDs(node);\n\n        // Check that we are not trying to remove are still active children.\n        // It is possible that Parent was removed from the DOM but its children should stay in DOM (was reattached).\n        if (this.activeViews) {\n            ids = ids.filter(function(id) {\n                return this.activeViews.indexOf(id) < 0;\n            }, this);\n        }\n\n        if (node.hasAttribute(Attrs.ID)) {\n            ids.unshift(node.getAttribute(Attrs.ID));\n        }\n\n        this.publishEvent(ids, Events.DETACH);\n    },\n\n    isOnPage: function(node) {\n        return document.body.contains(node);\n    },\n\n    onPatchStart: function(node) {\n        if (!this.isOnPage(node)) {\n            return;\n        }\n\n        var views = this.getChildIDs(node);\n\n        if (node.hasAttribute(Attrs.ID)) {\n            views.unshift(node.getAttribute(Attrs.ID));\n        }\n\n        this.activePatches.push({\n            node: node,\n            views: views\n        });\n    },\n\n    onPatchEnd: function(node) {\n        if (!this.isOnPage(node)) {\n            return;\n        }\n\n        var patchData = this.activePatches.pop();\n\n        if (patchData.node !== node) {\n            throw new Error('Wrong patch order');\n        }\n\n        this.refreshLayout(patchData);\n    },\n\n    getChildIDs: function (el) {\n        var els = el.querySelectorAll('['+Attrs.ID+']');\n        var ids = [];\n        var index = 0;\n\n        for (index; index < els.length; index++) {\n            ids[index] = els[index].getAttribute(Attrs.ID);\n        }\n\n        return ids;\n    },\n\n    refreshLayout: function(patchData) {\n        var node = patchData.node;\n        var viewsBefore = patchData.views;\n        var viewsAfter = this.getChildIDs(node);\n\n        if (node.hasAttribute(Attrs.ID)) {\n            viewsAfter.unshift(node.getAttribute(Attrs.ID));\n        }\n\n        this.activeViews = viewsAfter;\n        var detachedViews = _.difference(viewsBefore, viewsAfter);\n        this.publishEvent(detachedViews, Events.DETACH);\n\n        var attachedViews = _.difference(viewsAfter, viewsBefore);\n        this.publishEvent(attachedViews, Events.ATTACH);\n        this.activeViews = null;\n    },\n\n    publishEvent: function(subscribers, event) {\n        subscribers.forEach(function(id){\n            this.publish(id + ':' + event);\n        }, this);\n    }\n});\n\nmodule.exports = new LayoutManager();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/layout_manager/index.js\n ** module id = 23\n ** module chunks = 0\n **/","\"use strict\";\nvar _ = require('underscore');\nvar Backbone = require('backbone');\nvar Dispatcher = require('../core/dispatcher');\n\nvar moduleOptions = ['channel', 'id'];\n\nfunction Module(options) {\n    this.cid = _.uniqueId('module');\n\n    _.extend(this, _.pick(options, moduleOptions));\n\n    this.id = _.result(this, 'id', this.cid);\n    this.initialize.apply(this, arguments);\n\n    if (this.channel) {\n        this.subscribe(this.channel, this.onReceiveMsg, this);\n    }\n}\n\n_.extend( Module.prototype, Dispatcher, {\n    initialize: function () {},\n    onReceiveMsg: function () {},\n\n    destroy: function () {\n        this.unsubscribe(null,null, this);\n    }\n});\n\nModule.extend = Backbone.View.extend;\n\nmodule.exports = Module;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/blanks/module.js\n ** module id = 24\n ** module chunks = 0\n **/","\"use strict\";\nvar _ = require('underscore');\nvar core = require('../../core');\nvar Module = require('../../blanks/module');\nvar iDOM = require('../../template/idom');\nvar renderView = require('../../template/binder');\n\nvar Navigator = Module.extend({\n\n    initialize: function() {\n        this.subscribe('navigation:show', this.navigateView, this);\n        this.subscribe('navigation:back', this.navigateBack, this);\n\n        // Old API support\n        this.subscribe('navigation.show', this.navigateView, this);\n        this.subscribe('navigation.back', this.navigateBack, this);\n    },\n\n    /**\n     * @description\n     * Allow to navigate View with transition effects\n     *\n     * @param {Object} data\n     * @param {(String|HTMLElement)}    data.container          - CSS selector or HTMLElement where to attach new View\n     * @param {String}                  data.content            - View ID to show\n     *\n     * @param {String}                  [data.animation]        - animation name which will be applied for transition\n     * @param {Object}                  [data.extras]           - extra data that you can pass to the new View\n     *\n     * @callback doneCallback\n     * @param {doneCallback}            [data.callback]         - fires on transition end\n     */\n    navigateView: function(data) {\n        data = data || {};\n\n        var container = this.getEl(data.container);\n\n        if (!container) {\n            throw new Error('Cannot find container el: ' + data.container);\n        }\n\n        this.patchContainer(container, this.getContent(data.content), data.options);\n    },\n\n    navigateBack: function (data) {\n        data.direction = 'back';\n        this.navigateView(data);\n    },\n\n    getEl: function(selector) {\n        return _.isString(selector) ? document.querySelector(selector) : selector;\n    },\n\n    patchContainer: function(container, view, options) {\n        iDOM.patch(container, function() {\n            if (view) {\n                renderView(view, options);\n            }\n        });\n    },\n\n    getContent: function(content) {\n        if (_.isString(content)) {\n            return core.get(content);\n        }\n\n        return content;\n    }\n});\n\nmodule.exports = new Navigator();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugins/navigator/index.js\n ** module id = 25\n ** module chunks = 0\n **/","\"use strict\";\n\nmodule.exports.template = require('./../template');\nmodule.exports.IncrementalDOM = require('./../template/idom');\nmodule.exports.TransitionEnd = require('./transition/transitionEnd');\nmodule.exports.AnimationEnd = require('./transition/animationEnd');\nmodule.exports.DOM = require('./DOM_Utils');\n\n// todo remove binder after redesign component constructor\nmodule.exports.ITemplate = require('idom-template');\nmodule.exports.binder = require('../template/binder');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/index.js\n ** module id = 26\n ** module chunks = 0\n **/"],"sourceRoot":""}